//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 D:\\~Compilador\\!yatc\\Grammar\\tiger.g 2014-03-10 18:42:49

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019

 
	using System;


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

namespace YATC.Grammar
{
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class tigerParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "ALIAS_DECL", "AND", "ARGS_FIELDS", "ARRAYKEY", "ARRAY_ACCESS", "ARRAY_DECL", "ARRAY_INST", "ASCII_ESC", "ASSIGN", "BEGIN_COMMENT", "BREAK", "BREAKKEY", "COLON", "COMMA", "COMMENTARY", "DECL_BLOCK", "DIGIT", "DIV", "DOKEY", "DOT", "ELSEKEY", "ENDKEY", "END_COMMENT", "EQ", "ESC_SEQ", "EXPR_SEQ", "FIELDS_INST", "FIELD_ACCESS", "FIELD_ACCESS_TERMINAL", "FIELD_INST", "FILL_IN_TYPE", "FOR", "FORKEY", "FUNCTIONKEY", "FUN_CALL", "FUN_DECL", "FUN_DECL_SEQ", "FUN_TYPE_WRAPPER", "GT", "GTEQ", "ID", "IF", "IFKEY", "INKEY", "INT", "INTKEY", "LBRACKET", "LET", "LETKEY", "LETTER", "LKEY", "LPAREN", "LT", "LTEQ", "MINUS", "MULT", "NEG", "NIL", "NILKEY", "NOTEQ", "OFKEY", "OR", "PARAM_DECL", "PLUS", "PRINTABLE_CHARACTER", "PROGRAM", "QUOTE", "RBRACKET", "RECORD_DECL", "RECORD_INST", "RKEY", "RPAREN", "SEMI", "STRING", "STRINGKEY", "THENKEY", "TOKEY", "TYPE", "TYPEKEY", "TYPE_DECL", "TYPE_DECL_SEQ", "TYPE_FIELD", "VARKEY", "VAR_ACCESS", "VAR_DECL", "WHILE", "WHILEKEY", "WS"
	};
	public const int EOF=-1;
	public const int ALIAS_DECL=4;
	public const int AND=5;
	public const int ARGS_FIELDS=6;
	public const int ARRAYKEY=7;
	public const int ARRAY_ACCESS=8;
	public const int ARRAY_DECL=9;
	public const int ARRAY_INST=10;
	public const int ASCII_ESC=11;
	public const int ASSIGN=12;
	public const int BEGIN_COMMENT=13;
	public const int BREAK=14;
	public const int BREAKKEY=15;
	public const int COLON=16;
	public const int COMMA=17;
	public const int COMMENTARY=18;
	public const int DECL_BLOCK=19;
	public const int DIGIT=20;
	public const int DIV=21;
	public const int DOKEY=22;
	public const int DOT=23;
	public const int ELSEKEY=24;
	public const int ENDKEY=25;
	public const int END_COMMENT=26;
	public const int EQ=27;
	public const int ESC_SEQ=28;
	public const int EXPR_SEQ=29;
	public const int FIELDS_INST=30;
	public const int FIELD_ACCESS=31;
	public const int FIELD_ACCESS_TERMINAL=32;
	public const int FIELD_INST=33;
	public const int FILL_IN_TYPE=34;
	public const int FOR=35;
	public const int FORKEY=36;
	public const int FUNCTIONKEY=37;
	public const int FUN_CALL=38;
	public const int FUN_DECL=39;
	public const int FUN_DECL_SEQ=40;
	public const int FUN_TYPE_WRAPPER=41;
	public const int GT=42;
	public const int GTEQ=43;
	public const int ID=44;
	public const int IF=45;
	public const int IFKEY=46;
	public const int INKEY=47;
	public const int INT=48;
	public const int INTKEY=49;
	public const int LBRACKET=50;
	public const int LET=51;
	public const int LETKEY=52;
	public const int LETTER=53;
	public const int LKEY=54;
	public const int LPAREN=55;
	public const int LT=56;
	public const int LTEQ=57;
	public const int MINUS=58;
	public const int MULT=59;
	public const int NEG=60;
	public const int NIL=61;
	public const int NILKEY=62;
	public const int NOTEQ=63;
	public const int OFKEY=64;
	public const int OR=65;
	public const int PARAM_DECL=66;
	public const int PLUS=67;
	public const int PRINTABLE_CHARACTER=68;
	public const int PROGRAM=69;
	public const int QUOTE=70;
	public const int RBRACKET=71;
	public const int RECORD_DECL=72;
	public const int RECORD_INST=73;
	public const int RKEY=74;
	public const int RPAREN=75;
	public const int SEMI=76;
	public const int STRING=77;
	public const int STRINGKEY=78;
	public const int THENKEY=79;
	public const int TOKEY=80;
	public const int TYPE=81;
	public const int TYPEKEY=82;
	public const int TYPE_DECL=83;
	public const int TYPE_DECL_SEQ=84;
	public const int TYPE_FIELD=85;
	public const int VARKEY=86;
	public const int VAR_ACCESS=87;
	public const int VAR_DECL=88;
	public const int WHILE=89;
	public const int WHILEKEY=90;
	public const int WS=91;

	public tigerParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public tigerParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return tigerParser.tokenNames; } }
	public override string GrammarFileName { get { return "D:\\~Compilador\\!yatc\\Grammar\\tiger.g"; } }


	    public override void ReportError(RecognitionException exc) 
		{ 
			/* Abort on first error. */
			throw new ParsingException(GetErrorMessage(exc, TokenNames), exc);
	    } 


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_a_program();
	partial void LeaveRule_a_program();

	// $ANTLR start "a_program"
	// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:218:8: public a_program : ( expr )? EOF -> ^( PROGRAM ( expr )? ) ;
	[GrammarRule("a_program")]
	public AstParserRuleReturnScope<object, IToken> a_program()
	{
		EnterRule_a_program();
		EnterRule("a_program", 1);
		TraceIn("a_program", 1);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken EOF2 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expr1 = default(AstParserRuleReturnScope<object, IToken>);

		object EOF2_tree = default(object);
		RewriteRuleITokenStream stream_EOF=new RewriteRuleITokenStream(adaptor,"token EOF");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		try { DebugEnterRule(GrammarFileName, "a_program");
		DebugLocation(218, 23);
		try
		{
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:219:2: ( ( expr )? EOF -> ^( PROGRAM ( expr )? ) )
			DebugEnterAlt(1);
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:219:4: ( expr )? EOF
			{
			DebugLocation(219, 4);
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:219:4: ( expr )?
			int alt1=2;
			try { DebugEnterSubRule(1);
			try { DebugEnterDecision(1, false);
			int LA1_0 = input.LA(1);

			if ((LA1_0==BREAKKEY||LA1_0==FORKEY||LA1_0==ID||LA1_0==IFKEY||(LA1_0>=INT && LA1_0<=INTKEY)||LA1_0==LETKEY||LA1_0==LPAREN||LA1_0==MINUS||LA1_0==NILKEY||(LA1_0>=STRING && LA1_0<=STRINGKEY)||LA1_0==WHILEKEY))
			{
				alt1 = 1;
			}
			} finally { DebugExitDecision(1); }
			switch (alt1)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:219:4: expr
				{
				DebugLocation(219, 4);
				PushFollow(Follow._expr_in_a_program1145);
				expr1=expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expr.Add(expr1.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(1); }

			DebugLocation(219, 11);
			EOF2=(IToken)Match(input,EOF,Follow._EOF_in_a_program1149); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_EOF.Add(EOF2);



			{
			// AST REWRITE
			// elements: expr
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 220:3: -> ^( PROGRAM ( expr )? )
			{
				DebugLocation(220, 6);
				// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:220:6: ^( PROGRAM ( expr )? )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(220, 8);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(PROGRAM, "PROGRAM"), root_1);

				DebugLocation(220, 16);
				// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:220:16: ( expr )?
				if (stream_expr.HasNext)
				{
					DebugLocation(220, 16);
					adaptor.AddChild(root_1, stream_expr.NextTree());

				}
				stream_expr.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("a_program", 1);
			LeaveRule("a_program", 1);
			LeaveRule_a_program();
		}
		DebugLocation(220, 23);
		} finally { DebugExitRule(GrammarFileName, "a_program"); }
		return retval;

	}
	// $ANTLR end "a_program"

	partial void EnterRule_expr();
	partial void LeaveRule_expr();

	// $ANTLR start "expr"
	// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:222:1: expr : ( ( ID LBRACKET disjunction_expr RBRACKET OFKEY )=> array_inst | ( lvalue ASSIGN )=> assignment | disjunction_expr | record_inst | while_stat | BREAKKEY -> BREAK );
	[GrammarRule("expr")]
	private AstParserRuleReturnScope<object, IToken> expr()
	{
		EnterRule_expr();
		EnterRule("expr", 2);
		TraceIn("expr", 2);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken BREAKKEY8 = default(IToken);
		AstParserRuleReturnScope<object, IToken> array_inst3 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> assignment4 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> disjunction_expr5 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> record_inst6 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> while_stat7 = default(AstParserRuleReturnScope<object, IToken>);

		object BREAKKEY8_tree = default(object);
		RewriteRuleITokenStream stream_BREAKKEY=new RewriteRuleITokenStream(adaptor,"token BREAKKEY");
		try { DebugEnterRule(GrammarFileName, "expr");
		DebugLocation(222, 1);
		try
		{
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:223:2: ( ( ID LBRACKET disjunction_expr RBRACKET OFKEY )=> array_inst | ( lvalue ASSIGN )=> assignment | disjunction_expr | record_inst | while_stat | BREAKKEY -> BREAK )
			int alt2=6;
			try { DebugEnterDecision(2, false);
			try
			{
				alt2 = dfa2.Predict(input);
			}
			catch (NoViableAltException nvae)
			{
				DebugRecognitionException(nvae);
				throw;
			}
			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:223:4: ( ID LBRACKET disjunction_expr RBRACKET OFKEY )=> array_inst
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(223, 53);
				PushFollow(Follow._array_inst_in_expr1185);
				array_inst3=array_inst();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, array_inst3.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:224:4: ( lvalue ASSIGN )=> assignment
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(224, 23);
				PushFollow(Follow._assignment_in_expr1198);
				assignment4=assignment();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, assignment4.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:225:4: disjunction_expr
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(225, 4);
				PushFollow(Follow._disjunction_expr_in_expr1203);
				disjunction_expr5=disjunction_expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, disjunction_expr5.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:226:4: record_inst
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(226, 4);
				PushFollow(Follow._record_inst_in_expr1209);
				record_inst6=record_inst();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, record_inst6.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:227:4: while_stat
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(227, 4);
				PushFollow(Follow._while_stat_in_expr1214);
				while_stat7=while_stat();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, while_stat7.Tree);

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:228:4: BREAKKEY
				{
				DebugLocation(228, 4);
				BREAKKEY8=(IToken)Match(input,BREAKKEY,Follow._BREAKKEY_in_expr1219); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_BREAKKEY.Add(BREAKKEY8);



				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 229:13: -> BREAK
				{
					DebugLocation(229, 16);
					adaptor.AddChild(root_0, (object)adaptor.Create(BREAK, "BREAK"));

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expr", 2);
			LeaveRule("expr", 2);
			LeaveRule_expr();
		}
		DebugLocation(230, 1);
		} finally { DebugExitRule(GrammarFileName, "expr"); }
		return retval;

	}
	// $ANTLR end "expr"

	partial void EnterRule_disjunction_expr();
	partial void LeaveRule_disjunction_expr();

	// $ANTLR start "disjunction_expr"
	// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:232:1: disjunction_expr : conjunction_expr ( OR ^ conjunction_expr )* ;
	[GrammarRule("disjunction_expr")]
	private AstParserRuleReturnScope<object, IToken> disjunction_expr()
	{
		EnterRule_disjunction_expr();
		EnterRule("disjunction_expr", 3);
		TraceIn("disjunction_expr", 3);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken OR10 = default(IToken);
		AstParserRuleReturnScope<object, IToken> conjunction_expr9 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> conjunction_expr11 = default(AstParserRuleReturnScope<object, IToken>);

		object OR10_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "disjunction_expr");
		DebugLocation(232, 1);
		try
		{
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:233:2: ( conjunction_expr ( OR ^ conjunction_expr )* )
			DebugEnterAlt(1);
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:233:4: conjunction_expr ( OR ^ conjunction_expr )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(233, 4);
			PushFollow(Follow._conjunction_expr_in_disjunction_expr1248);
			conjunction_expr9=conjunction_expr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, conjunction_expr9.Tree);
			DebugLocation(233, 21);
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:233:21: ( OR ^ conjunction_expr )*
			try { DebugEnterSubRule(3);
			while (true)
			{
				int alt3=2;
				try { DebugEnterDecision(3, false);
				int LA3_0 = input.LA(1);

				if ((LA3_0==OR))
				{
					alt3 = 1;
				}


				} finally { DebugExitDecision(3); }
				switch ( alt3 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:233:22: OR ^ conjunction_expr
					{
					DebugLocation(233, 24);
					OR10=(IToken)Match(input,OR,Follow._OR_in_disjunction_expr1251); if (state.failed) return retval;
					if (state.backtracking == 0) {
					OR10_tree = (object)adaptor.Create(OR10);
					root_0 = (object)adaptor.BecomeRoot(OR10_tree, root_0);
					}
					DebugLocation(233, 26);
					PushFollow(Follow._conjunction_expr_in_disjunction_expr1254);
					conjunction_expr11=conjunction_expr();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, conjunction_expr11.Tree);

					}
					break;

				default:
					goto loop3;
				}
			}

			loop3:
				;

			} finally { DebugExitSubRule(3); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("disjunction_expr", 3);
			LeaveRule("disjunction_expr", 3);
			LeaveRule_disjunction_expr();
		}
		DebugLocation(234, 1);
		} finally { DebugExitRule(GrammarFileName, "disjunction_expr"); }
		return retval;

	}
	// $ANTLR end "disjunction_expr"

	partial void EnterRule_assignment();
	partial void LeaveRule_assignment();

	// $ANTLR start "assignment"
	// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:236:1: assignment : lvalue ASSIGN ^ ( ( ID LBRACKET disjunction_expr RBRACKET OFKEY )=> array_inst | disjunction_expr | record_inst ) ;
	[GrammarRule("assignment")]
	private AstParserRuleReturnScope<object, IToken> assignment()
	{
		EnterRule_assignment();
		EnterRule("assignment", 4);
		TraceIn("assignment", 4);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ASSIGN13 = default(IToken);
		AstParserRuleReturnScope<object, IToken> lvalue12 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> array_inst14 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> disjunction_expr15 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> record_inst16 = default(AstParserRuleReturnScope<object, IToken>);

		object ASSIGN13_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "assignment");
		DebugLocation(236, 1);
		try
		{
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:237:2: ( lvalue ASSIGN ^ ( ( ID LBRACKET disjunction_expr RBRACKET OFKEY )=> array_inst | disjunction_expr | record_inst ) )
			DebugEnterAlt(1);
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:237:4: lvalue ASSIGN ^ ( ( ID LBRACKET disjunction_expr RBRACKET OFKEY )=> array_inst | disjunction_expr | record_inst )
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(237, 4);
			PushFollow(Follow._lvalue_in_assignment1267);
			lvalue12=lvalue();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, lvalue12.Tree);
			DebugLocation(237, 17);
			ASSIGN13=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_assignment1269); if (state.failed) return retval;
			if (state.backtracking == 0) {
			ASSIGN13_tree = (object)adaptor.Create(ASSIGN13);
			root_0 = (object)adaptor.BecomeRoot(ASSIGN13_tree, root_0);
			}
			DebugLocation(238, 4);
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:238:4: ( ( ID LBRACKET disjunction_expr RBRACKET OFKEY )=> array_inst | disjunction_expr | record_inst )
			int alt4=3;
			try { DebugEnterSubRule(4);
			try { DebugEnterDecision(4, false);
			int LA4_0 = input.LA(1);

			if ((LA4_0==ID))
			{
				switch (input.LA(2))
				{
				case LBRACKET:
					{
					switch (input.LA(3))
					{
					case MINUS:
						{
						int LA4_33 = input.LA(4);

						if ((EvaluatePredicate(synpred3_tiger_fragment)))
						{
							alt4 = 1;
						}
						else if ((true))
						{
							alt4 = 2;
						}
						else
						{
							if (state.backtracking>0) {state.failed=true; return retval;}
							NoViableAltException nvae = new NoViableAltException("", 4, 33, input);
							DebugRecognitionException(nvae);
							throw nvae;
						}
						}
						break;
					case INT:
					case NILKEY:
					case STRING:
						{
						int LA4_34 = input.LA(4);

						if ((EvaluatePredicate(synpred3_tiger_fragment)))
						{
							alt4 = 1;
						}
						else if ((true))
						{
							alt4 = 2;
						}
						else
						{
							if (state.backtracking>0) {state.failed=true; return retval;}
							NoViableAltException nvae = new NoViableAltException("", 4, 34, input);
							DebugRecognitionException(nvae);
							throw nvae;
						}
						}
						break;
					case ID:
					case INTKEY:
					case STRINGKEY:
						{
						int LA4_35 = input.LA(4);

						if ((EvaluatePredicate(synpred3_tiger_fragment)))
						{
							alt4 = 1;
						}
						else if ((true))
						{
							alt4 = 2;
						}
						else
						{
							if (state.backtracking>0) {state.failed=true; return retval;}
							NoViableAltException nvae = new NoViableAltException("", 4, 35, input);
							DebugRecognitionException(nvae);
							throw nvae;
						}
						}
						break;
					case IFKEY:
						{
						int LA4_36 = input.LA(4);

						if ((EvaluatePredicate(synpred3_tiger_fragment)))
						{
							alt4 = 1;
						}
						else if ((true))
						{
							alt4 = 2;
						}
						else
						{
							if (state.backtracking>0) {state.failed=true; return retval;}
							NoViableAltException nvae = new NoViableAltException("", 4, 36, input);
							DebugRecognitionException(nvae);
							throw nvae;
						}
						}
						break;
					case FORKEY:
						{
						int LA4_37 = input.LA(4);

						if ((EvaluatePredicate(synpred3_tiger_fragment)))
						{
							alt4 = 1;
						}
						else if ((true))
						{
							alt4 = 2;
						}
						else
						{
							if (state.backtracking>0) {state.failed=true; return retval;}
							NoViableAltException nvae = new NoViableAltException("", 4, 37, input);
							DebugRecognitionException(nvae);
							throw nvae;
						}
						}
						break;
					case LETKEY:
						{
						int LA4_38 = input.LA(4);

						if ((EvaluatePredicate(synpred3_tiger_fragment)))
						{
							alt4 = 1;
						}
						else if ((true))
						{
							alt4 = 2;
						}
						else
						{
							if (state.backtracking>0) {state.failed=true; return retval;}
							NoViableAltException nvae = new NoViableAltException("", 4, 38, input);
							DebugRecognitionException(nvae);
							throw nvae;
						}
						}
						break;
					case LPAREN:
						{
						int LA4_39 = input.LA(4);

						if ((EvaluatePredicate(synpred3_tiger_fragment)))
						{
							alt4 = 1;
						}
						else if ((true))
						{
							alt4 = 2;
						}
						else
						{
							if (state.backtracking>0) {state.failed=true; return retval;}
							NoViableAltException nvae = new NoViableAltException("", 4, 39, input);
							DebugRecognitionException(nvae);
							throw nvae;
						}
						}
						break;
					default:
						{
							if (state.backtracking>0) {state.failed=true; return retval;}
							NoViableAltException nvae = new NoViableAltException("", 4, 9, input);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}

					}
					break;
				case LKEY:
					{
					alt4 = 3;
					}
					break;
				case EOF:
				case AND:
				case COMMA:
				case DIV:
				case DOKEY:
				case DOT:
				case ELSEKEY:
				case ENDKEY:
				case EQ:
				case FUNCTIONKEY:
				case GT:
				case GTEQ:
				case INKEY:
				case LPAREN:
				case LT:
				case LTEQ:
				case MINUS:
				case MULT:
				case NOTEQ:
				case OR:
				case PLUS:
				case RBRACKET:
				case RKEY:
				case RPAREN:
				case SEMI:
				case THENKEY:
				case TOKEY:
				case TYPEKEY:
				case VARKEY:
					{
					alt4 = 2;
					}
					break;
				default:
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 4, 1, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}

			}
			else if ((LA4_0==FORKEY||LA4_0==IFKEY||(LA4_0>=INT && LA4_0<=INTKEY)||LA4_0==LETKEY||LA4_0==LPAREN||LA4_0==MINUS||LA4_0==NILKEY||(LA4_0>=STRING && LA4_0<=STRINGKEY)))
			{
				alt4 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 4, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(4); }
			switch (alt4)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:238:6: ( ID LBRACKET disjunction_expr RBRACKET OFKEY )=> array_inst
				{
				DebugLocation(238, 55);
				PushFollow(Follow._array_inst_in_assignment1292);
				array_inst14=array_inst();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, array_inst14.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:239:6: disjunction_expr
				{
				DebugLocation(239, 6);
				PushFollow(Follow._disjunction_expr_in_assignment1300);
				disjunction_expr15=disjunction_expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, disjunction_expr15.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:240:6: record_inst
				{
				DebugLocation(240, 6);
				PushFollow(Follow._record_inst_in_assignment1308);
				record_inst16=record_inst();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, record_inst16.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(4); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("assignment", 4);
			LeaveRule("assignment", 4);
			LeaveRule_assignment();
		}
		DebugLocation(242, 1);
		} finally { DebugExitRule(GrammarFileName, "assignment"); }
		return retval;

	}
	// $ANTLR end "assignment"

	partial void EnterRule_record_inst();
	partial void LeaveRule_record_inst();

	// $ANTLR start "record_inst"
	// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:244:1: record_inst : ID LKEY ( field_inst_list )? RKEY -> ^( RECORD_INST ID ( field_inst_list )? ) ;
	[GrammarRule("record_inst")]
	private AstParserRuleReturnScope<object, IToken> record_inst()
	{
		EnterRule_record_inst();
		EnterRule("record_inst", 5);
		TraceIn("record_inst", 5);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID17 = default(IToken);
		IToken LKEY18 = default(IToken);
		IToken RKEY20 = default(IToken);
		AstParserRuleReturnScope<object, IToken> field_inst_list19 = default(AstParserRuleReturnScope<object, IToken>);

		object ID17_tree = default(object);
		object LKEY18_tree = default(object);
		object RKEY20_tree = default(object);
		RewriteRuleITokenStream stream_LKEY=new RewriteRuleITokenStream(adaptor,"token LKEY");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_RKEY=new RewriteRuleITokenStream(adaptor,"token RKEY");
		RewriteRuleSubtreeStream stream_field_inst_list=new RewriteRuleSubtreeStream(adaptor,"rule field_inst_list");
		try { DebugEnterRule(GrammarFileName, "record_inst");
		DebugLocation(244, 1);
		try
		{
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:245:2: ( ID LKEY ( field_inst_list )? RKEY -> ^( RECORD_INST ID ( field_inst_list )? ) )
			DebugEnterAlt(1);
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:245:4: ID LKEY ( field_inst_list )? RKEY
			{
			DebugLocation(245, 4);
			ID17=(IToken)Match(input,ID,Follow._ID_in_record_inst1325); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(ID17);

			DebugLocation(245, 7);
			LKEY18=(IToken)Match(input,LKEY,Follow._LKEY_in_record_inst1327); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LKEY.Add(LKEY18);

			DebugLocation(245, 12);
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:245:12: ( field_inst_list )?
			int alt5=2;
			try { DebugEnterSubRule(5);
			try { DebugEnterDecision(5, false);
			int LA5_0 = input.LA(1);

			if ((LA5_0==ID))
			{
				alt5 = 1;
			}
			} finally { DebugExitDecision(5); }
			switch (alt5)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:245:12: field_inst_list
				{
				DebugLocation(245, 12);
				PushFollow(Follow._field_inst_list_in_record_inst1329);
				field_inst_list19=field_inst_list();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_field_inst_list.Add(field_inst_list19.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(5); }

			DebugLocation(245, 29);
			RKEY20=(IToken)Match(input,RKEY,Follow._RKEY_in_record_inst1332); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RKEY.Add(RKEY20);



			{
			// AST REWRITE
			// elements: ID, field_inst_list
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 246:4: -> ^( RECORD_INST ID ( field_inst_list )? )
			{
				DebugLocation(246, 7);
				// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:246:7: ^( RECORD_INST ID ( field_inst_list )? )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(246, 9);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(RECORD_INST, "RECORD_INST"), root_1);

				DebugLocation(246, 21);
				adaptor.AddChild(root_1, stream_ID.NextNode());
				DebugLocation(246, 24);
				// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:246:24: ( field_inst_list )?
				if (stream_field_inst_list.HasNext)
				{
					DebugLocation(246, 24);
					adaptor.AddChild(root_1, stream_field_inst_list.NextTree());

				}
				stream_field_inst_list.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("record_inst", 5);
			LeaveRule("record_inst", 5);
			LeaveRule_record_inst();
		}
		DebugLocation(247, 1);
		} finally { DebugExitRule(GrammarFileName, "record_inst"); }
		return retval;

	}
	// $ANTLR end "record_inst"

	partial void EnterRule_for_expr();
	partial void LeaveRule_for_expr();

	// $ANTLR start "for_expr"
	// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:254:1: for_expr : FORKEY type_id ASSIGN disjunction_expr TOKEY disjunction_expr DOKEY expr -> ^( FOR type_id disjunction_expr disjunction_expr expr ) ;
	[GrammarRule("for_expr")]
	private AstParserRuleReturnScope<object, IToken> for_expr()
	{
		EnterRule_for_expr();
		EnterRule("for_expr", 6);
		TraceIn("for_expr", 6);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken FORKEY21 = default(IToken);
		IToken ASSIGN23 = default(IToken);
		IToken TOKEY25 = default(IToken);
		IToken DOKEY27 = default(IToken);
		AstParserRuleReturnScope<object, IToken> type_id22 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> disjunction_expr24 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> disjunction_expr26 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expr28 = default(AstParserRuleReturnScope<object, IToken>);

		object FORKEY21_tree = default(object);
		object ASSIGN23_tree = default(object);
		object TOKEY25_tree = default(object);
		object DOKEY27_tree = default(object);
		RewriteRuleITokenStream stream_TOKEY=new RewriteRuleITokenStream(adaptor,"token TOKEY");
		RewriteRuleITokenStream stream_FORKEY=new RewriteRuleITokenStream(adaptor,"token FORKEY");
		RewriteRuleITokenStream stream_DOKEY=new RewriteRuleITokenStream(adaptor,"token DOKEY");
		RewriteRuleITokenStream stream_ASSIGN=new RewriteRuleITokenStream(adaptor,"token ASSIGN");
		RewriteRuleSubtreeStream stream_type_id=new RewriteRuleSubtreeStream(adaptor,"rule type_id");
		RewriteRuleSubtreeStream stream_disjunction_expr=new RewriteRuleSubtreeStream(adaptor,"rule disjunction_expr");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		try { DebugEnterRule(GrammarFileName, "for_expr");
		DebugLocation(254, 1);
		try
		{
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:255:2: ( FORKEY type_id ASSIGN disjunction_expr TOKEY disjunction_expr DOKEY expr -> ^( FOR type_id disjunction_expr disjunction_expr expr ) )
			DebugEnterAlt(1);
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:255:4: FORKEY type_id ASSIGN disjunction_expr TOKEY disjunction_expr DOKEY expr
			{
			DebugLocation(255, 4);
			FORKEY21=(IToken)Match(input,FORKEY,Follow._FORKEY_in_for_expr1359); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_FORKEY.Add(FORKEY21);

			DebugLocation(255, 11);
			PushFollow(Follow._type_id_in_for_expr1361);
			type_id22=type_id();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_type_id.Add(type_id22.Tree);
			DebugLocation(255, 19);
			ASSIGN23=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_for_expr1363); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ASSIGN.Add(ASSIGN23);

			DebugLocation(255, 26);
			PushFollow(Follow._disjunction_expr_in_for_expr1365);
			disjunction_expr24=disjunction_expr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_disjunction_expr.Add(disjunction_expr24.Tree);
			DebugLocation(255, 43);
			TOKEY25=(IToken)Match(input,TOKEY,Follow._TOKEY_in_for_expr1367); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_TOKEY.Add(TOKEY25);

			DebugLocation(255, 49);
			PushFollow(Follow._disjunction_expr_in_for_expr1369);
			disjunction_expr26=disjunction_expr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_disjunction_expr.Add(disjunction_expr26.Tree);
			DebugLocation(255, 66);
			DOKEY27=(IToken)Match(input,DOKEY,Follow._DOKEY_in_for_expr1371); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_DOKEY.Add(DOKEY27);

			DebugLocation(255, 72);
			PushFollow(Follow._expr_in_for_expr1373);
			expr28=expr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expr.Add(expr28.Tree);


			{
			// AST REWRITE
			// elements: type_id, expr, disjunction_expr, disjunction_expr
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 256:4: -> ^( FOR type_id disjunction_expr disjunction_expr expr )
			{
				DebugLocation(256, 7);
				// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:256:7: ^( FOR type_id disjunction_expr disjunction_expr expr )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(256, 9);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(FOR, "FOR"), root_1);

				DebugLocation(256, 13);
				adaptor.AddChild(root_1, stream_type_id.NextTree());
				DebugLocation(256, 21);
				adaptor.AddChild(root_1, stream_disjunction_expr.NextTree());
				DebugLocation(256, 38);
				adaptor.AddChild(root_1, stream_disjunction_expr.NextTree());
				DebugLocation(256, 55);
				adaptor.AddChild(root_1, stream_expr.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("for_expr", 6);
			LeaveRule("for_expr", 6);
			LeaveRule_for_expr();
		}
		DebugLocation(257, 1);
		} finally { DebugExitRule(GrammarFileName, "for_expr"); }
		return retval;

	}
	// $ANTLR end "for_expr"

	partial void EnterRule_array_inst();
	partial void LeaveRule_array_inst();

	// $ANTLR start "array_inst"
	// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:259:1: array_inst : ID LBRACKET disjunction_expr RBRACKET OFKEY expr -> ^( ARRAY_INST ID disjunction_expr expr ) ;
	[GrammarRule("array_inst")]
	private AstParserRuleReturnScope<object, IToken> array_inst()
	{
		EnterRule_array_inst();
		EnterRule("array_inst", 7);
		TraceIn("array_inst", 7);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID29 = default(IToken);
		IToken LBRACKET30 = default(IToken);
		IToken RBRACKET32 = default(IToken);
		IToken OFKEY33 = default(IToken);
		AstParserRuleReturnScope<object, IToken> disjunction_expr31 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expr34 = default(AstParserRuleReturnScope<object, IToken>);

		object ID29_tree = default(object);
		object LBRACKET30_tree = default(object);
		object RBRACKET32_tree = default(object);
		object OFKEY33_tree = default(object);
		RewriteRuleITokenStream stream_OFKEY=new RewriteRuleITokenStream(adaptor,"token OFKEY");
		RewriteRuleITokenStream stream_LBRACKET=new RewriteRuleITokenStream(adaptor,"token LBRACKET");
		RewriteRuleITokenStream stream_RBRACKET=new RewriteRuleITokenStream(adaptor,"token RBRACKET");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleSubtreeStream stream_disjunction_expr=new RewriteRuleSubtreeStream(adaptor,"rule disjunction_expr");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		try { DebugEnterRule(GrammarFileName, "array_inst");
		DebugLocation(259, 1);
		try
		{
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:260:2: ( ID LBRACKET disjunction_expr RBRACKET OFKEY expr -> ^( ARRAY_INST ID disjunction_expr expr ) )
			DebugEnterAlt(1);
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:260:4: ID LBRACKET disjunction_expr RBRACKET OFKEY expr
			{
			DebugLocation(260, 4);
			ID29=(IToken)Match(input,ID,Follow._ID_in_array_inst1401); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(ID29);

			DebugLocation(260, 7);
			LBRACKET30=(IToken)Match(input,LBRACKET,Follow._LBRACKET_in_array_inst1403); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LBRACKET.Add(LBRACKET30);

			DebugLocation(260, 16);
			PushFollow(Follow._disjunction_expr_in_array_inst1405);
			disjunction_expr31=disjunction_expr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_disjunction_expr.Add(disjunction_expr31.Tree);
			DebugLocation(260, 33);
			RBRACKET32=(IToken)Match(input,RBRACKET,Follow._RBRACKET_in_array_inst1407); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RBRACKET.Add(RBRACKET32);

			DebugLocation(260, 42);
			OFKEY33=(IToken)Match(input,OFKEY,Follow._OFKEY_in_array_inst1409); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_OFKEY.Add(OFKEY33);

			DebugLocation(260, 48);
			PushFollow(Follow._expr_in_array_inst1411);
			expr34=expr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expr.Add(expr34.Tree);


			{
			// AST REWRITE
			// elements: ID, expr, disjunction_expr
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 261:4: -> ^( ARRAY_INST ID disjunction_expr expr )
			{
				DebugLocation(261, 7);
				// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:261:7: ^( ARRAY_INST ID disjunction_expr expr )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(261, 9);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ARRAY_INST, "ARRAY_INST"), root_1);

				DebugLocation(261, 20);
				adaptor.AddChild(root_1, stream_ID.NextNode());
				DebugLocation(261, 23);
				adaptor.AddChild(root_1, stream_disjunction_expr.NextTree());
				DebugLocation(261, 40);
				adaptor.AddChild(root_1, stream_expr.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("array_inst", 7);
			LeaveRule("array_inst", 7);
			LeaveRule_array_inst();
		}
		DebugLocation(262, 1);
		} finally { DebugExitRule(GrammarFileName, "array_inst"); }
		return retval;

	}
	// $ANTLR end "array_inst"

	partial void EnterRule_conjunction_expr();
	partial void LeaveRule_conjunction_expr();

	// $ANTLR start "conjunction_expr"
	// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:264:1: conjunction_expr : relational_expr ( AND ^ relational_expr )* ;
	[GrammarRule("conjunction_expr")]
	private AstParserRuleReturnScope<object, IToken> conjunction_expr()
	{
		EnterRule_conjunction_expr();
		EnterRule("conjunction_expr", 8);
		TraceIn("conjunction_expr", 8);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken AND36 = default(IToken);
		AstParserRuleReturnScope<object, IToken> relational_expr35 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> relational_expr37 = default(AstParserRuleReturnScope<object, IToken>);

		object AND36_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "conjunction_expr");
		DebugLocation(264, 1);
		try
		{
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:265:2: ( relational_expr ( AND ^ relational_expr )* )
			DebugEnterAlt(1);
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:265:4: relational_expr ( AND ^ relational_expr )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(265, 4);
			PushFollow(Follow._relational_expr_in_conjunction_expr1437);
			relational_expr35=relational_expr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, relational_expr35.Tree);
			DebugLocation(265, 20);
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:265:20: ( AND ^ relational_expr )*
			try { DebugEnterSubRule(6);
			while (true)
			{
				int alt6=2;
				try { DebugEnterDecision(6, false);
				int LA6_0 = input.LA(1);

				if ((LA6_0==AND))
				{
					alt6 = 1;
				}


				} finally { DebugExitDecision(6); }
				switch ( alt6 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:265:21: AND ^ relational_expr
					{
					DebugLocation(265, 24);
					AND36=(IToken)Match(input,AND,Follow._AND_in_conjunction_expr1440); if (state.failed) return retval;
					if (state.backtracking == 0) {
					AND36_tree = (object)adaptor.Create(AND36);
					root_0 = (object)adaptor.BecomeRoot(AND36_tree, root_0);
					}
					DebugLocation(265, 26);
					PushFollow(Follow._relational_expr_in_conjunction_expr1443);
					relational_expr37=relational_expr();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, relational_expr37.Tree);

					}
					break;

				default:
					goto loop6;
				}
			}

			loop6:
				;

			} finally { DebugExitSubRule(6); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("conjunction_expr", 8);
			LeaveRule("conjunction_expr", 8);
			LeaveRule_conjunction_expr();
		}
		DebugLocation(266, 1);
		} finally { DebugExitRule(GrammarFileName, "conjunction_expr"); }
		return retval;

	}
	// $ANTLR end "conjunction_expr"

	partial void EnterRule_relational_expr();
	partial void LeaveRule_relational_expr();

	// $ANTLR start "relational_expr"
	// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:273:1: relational_expr : arith_expr ( ( EQ | NOTEQ | GT | LT | GTEQ | LTEQ ) ^ arith_expr )? ;
	[GrammarRule("relational_expr")]
	private AstParserRuleReturnScope<object, IToken> relational_expr()
	{
		EnterRule_relational_expr();
		EnterRule("relational_expr", 9);
		TraceIn("relational_expr", 9);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set39 = default(IToken);
		AstParserRuleReturnScope<object, IToken> arith_expr38 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> arith_expr40 = default(AstParserRuleReturnScope<object, IToken>);

		object set39_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "relational_expr");
		DebugLocation(273, 1);
		try
		{
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:274:2: ( arith_expr ( ( EQ | NOTEQ | GT | LT | GTEQ | LTEQ ) ^ arith_expr )? )
			DebugEnterAlt(1);
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:274:4: arith_expr ( ( EQ | NOTEQ | GT | LT | GTEQ | LTEQ ) ^ arith_expr )?
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(274, 4);
			PushFollow(Follow._arith_expr_in_relational_expr1459);
			arith_expr38=arith_expr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, arith_expr38.Tree);
			DebugLocation(274, 15);
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:274:15: ( ( EQ | NOTEQ | GT | LT | GTEQ | LTEQ ) ^ arith_expr )?
			int alt7=2;
			try { DebugEnterSubRule(7);
			try { DebugEnterDecision(7, false);
			int LA7_0 = input.LA(1);

			if ((LA7_0==EQ||(LA7_0>=GT && LA7_0<=GTEQ)||(LA7_0>=LT && LA7_0<=LTEQ)||LA7_0==NOTEQ))
			{
				alt7 = 1;
			}
			} finally { DebugExitDecision(7); }
			switch (alt7)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:274:16: ( EQ | NOTEQ | GT | LT | GTEQ | LTEQ ) ^ arith_expr
				{
				DebugLocation(274, 53);

				set39=(IToken)input.LT(1);
				set39=(IToken)input.LT(1);
				if (input.LA(1)==EQ||(input.LA(1)>=GT && input.LA(1)<=GTEQ)||(input.LA(1)>=LT && input.LA(1)<=LTEQ)||input.LA(1)==NOTEQ)
				{
					input.Consume();
					if (state.backtracking == 0) root_0 = (object)adaptor.BecomeRoot((object)adaptor.Create(set39), root_0);
					state.errorRecovery=false;state.failed=false;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					MismatchedSetException mse = new MismatchedSetException(null,input);
					DebugRecognitionException(mse);
					throw mse;
				}

				DebugLocation(274, 55);
				PushFollow(Follow._arith_expr_in_relational_expr1488);
				arith_expr40=arith_expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, arith_expr40.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(7); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("relational_expr", 9);
			LeaveRule("relational_expr", 9);
			LeaveRule_relational_expr();
		}
		DebugLocation(275, 1);
		} finally { DebugExitRule(GrammarFileName, "relational_expr"); }
		return retval;

	}
	// $ANTLR end "relational_expr"

	partial void EnterRule_arith_expr();
	partial void LeaveRule_arith_expr();

	// $ANTLR start "arith_expr"
	// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:277:1: arith_expr : term_expr ( ( PLUS | MINUS ) ^ term_expr )* ;
	[GrammarRule("arith_expr")]
	private AstParserRuleReturnScope<object, IToken> arith_expr()
	{
		EnterRule_arith_expr();
		EnterRule("arith_expr", 10);
		TraceIn("arith_expr", 10);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set42 = default(IToken);
		AstParserRuleReturnScope<object, IToken> term_expr41 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> term_expr43 = default(AstParserRuleReturnScope<object, IToken>);

		object set42_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "arith_expr");
		DebugLocation(277, 1);
		try
		{
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:278:2: ( term_expr ( ( PLUS | MINUS ) ^ term_expr )* )
			DebugEnterAlt(1);
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:278:4: term_expr ( ( PLUS | MINUS ) ^ term_expr )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(278, 4);
			PushFollow(Follow._term_expr_in_arith_expr1502);
			term_expr41=term_expr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, term_expr41.Tree);
			DebugLocation(278, 14);
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:278:14: ( ( PLUS | MINUS ) ^ term_expr )*
			try { DebugEnterSubRule(8);
			while (true)
			{
				int alt8=2;
				try { DebugEnterDecision(8, false);
				int LA8_0 = input.LA(1);

				if ((LA8_0==MINUS||LA8_0==PLUS))
				{
					alt8 = 1;
				}


				} finally { DebugExitDecision(8); }
				switch ( alt8 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:278:15: ( PLUS | MINUS ) ^ term_expr
					{
					DebugLocation(278, 29);

					set42=(IToken)input.LT(1);
					set42=(IToken)input.LT(1);
					if (input.LA(1)==MINUS||input.LA(1)==PLUS)
					{
						input.Consume();
						if (state.backtracking == 0) root_0 = (object)adaptor.BecomeRoot((object)adaptor.Create(set42), root_0);
						state.errorRecovery=false;state.failed=false;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						MismatchedSetException mse = new MismatchedSetException(null,input);
						DebugRecognitionException(mse);
						throw mse;
					}

					DebugLocation(278, 31);
					PushFollow(Follow._term_expr_in_arith_expr1514);
					term_expr43=term_expr();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, term_expr43.Tree);

					}
					break;

				default:
					goto loop8;
				}
			}

			loop8:
				;

			} finally { DebugExitSubRule(8); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("arith_expr", 10);
			LeaveRule("arith_expr", 10);
			LeaveRule_arith_expr();
		}
		DebugLocation(279, 1);
		} finally { DebugExitRule(GrammarFileName, "arith_expr"); }
		return retval;

	}
	// $ANTLR end "arith_expr"

	partial void EnterRule_term_expr();
	partial void LeaveRule_term_expr();

	// $ANTLR start "term_expr"
	// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:281:1: term_expr : atom ( ( MULT | DIV ) ^ atom )* ;
	[GrammarRule("term_expr")]
	private AstParserRuleReturnScope<object, IToken> term_expr()
	{
		EnterRule_term_expr();
		EnterRule("term_expr", 11);
		TraceIn("term_expr", 11);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set45 = default(IToken);
		AstParserRuleReturnScope<object, IToken> atom44 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> atom46 = default(AstParserRuleReturnScope<object, IToken>);

		object set45_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "term_expr");
		DebugLocation(281, 1);
		try
		{
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:282:2: ( atom ( ( MULT | DIV ) ^ atom )* )
			DebugEnterAlt(1);
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:282:4: atom ( ( MULT | DIV ) ^ atom )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(282, 4);
			PushFollow(Follow._atom_in_term_expr1527);
			atom44=atom();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) adaptor.AddChild(root_0, atom44.Tree);
			DebugLocation(282, 9);
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:282:9: ( ( MULT | DIV ) ^ atom )*
			try { DebugEnterSubRule(9);
			while (true)
			{
				int alt9=2;
				try { DebugEnterDecision(9, false);
				int LA9_0 = input.LA(1);

				if ((LA9_0==DIV||LA9_0==MULT))
				{
					alt9 = 1;
				}


				} finally { DebugExitDecision(9); }
				switch ( alt9 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:282:10: ( MULT | DIV ) ^ atom
					{
					DebugLocation(282, 22);

					set45=(IToken)input.LT(1);
					set45=(IToken)input.LT(1);
					if (input.LA(1)==DIV||input.LA(1)==MULT)
					{
						input.Consume();
						if (state.backtracking == 0) root_0 = (object)adaptor.BecomeRoot((object)adaptor.Create(set45), root_0);
						state.errorRecovery=false;state.failed=false;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						MismatchedSetException mse = new MismatchedSetException(null,input);
						DebugRecognitionException(mse);
						throw mse;
					}

					DebugLocation(282, 24);
					PushFollow(Follow._atom_in_term_expr1539);
					atom46=atom();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) adaptor.AddChild(root_0, atom46.Tree);

					}
					break;

				default:
					goto loop9;
				}
			}

			loop9:
				;

			} finally { DebugExitSubRule(9); }


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("term_expr", 11);
			LeaveRule("term_expr", 11);
			LeaveRule_term_expr();
		}
		DebugLocation(283, 1);
		} finally { DebugExitRule(GrammarFileName, "term_expr"); }
		return retval;

	}
	// $ANTLR end "term_expr"

	partial void EnterRule_field_inst_list();
	partial void LeaveRule_field_inst_list();

	// $ANTLR start "field_inst_list"
	// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:285:1: field_inst_list : record_field_inst ( COMMA record_field_inst )* -> ^( FIELDS_INST ( record_field_inst )+ ) ;
	[GrammarRule("field_inst_list")]
	private AstParserRuleReturnScope<object, IToken> field_inst_list()
	{
		EnterRule_field_inst_list();
		EnterRule("field_inst_list", 12);
		TraceIn("field_inst_list", 12);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken COMMA48 = default(IToken);
		AstParserRuleReturnScope<object, IToken> record_field_inst47 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> record_field_inst49 = default(AstParserRuleReturnScope<object, IToken>);

		object COMMA48_tree = default(object);
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_record_field_inst=new RewriteRuleSubtreeStream(adaptor,"rule record_field_inst");
		try { DebugEnterRule(GrammarFileName, "field_inst_list");
		DebugLocation(285, 1);
		try
		{
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:286:2: ( record_field_inst ( COMMA record_field_inst )* -> ^( FIELDS_INST ( record_field_inst )+ ) )
			DebugEnterAlt(1);
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:286:5: record_field_inst ( COMMA record_field_inst )*
			{
			DebugLocation(286, 5);
			PushFollow(Follow._record_field_inst_in_field_inst_list1553);
			record_field_inst47=record_field_inst();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_record_field_inst.Add(record_field_inst47.Tree);
			DebugLocation(286, 23);
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:286:23: ( COMMA record_field_inst )*
			try { DebugEnterSubRule(10);
			while (true)
			{
				int alt10=2;
				try { DebugEnterDecision(10, false);
				int LA10_0 = input.LA(1);

				if ((LA10_0==COMMA))
				{
					alt10 = 1;
				}


				} finally { DebugExitDecision(10); }
				switch ( alt10 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:286:25: COMMA record_field_inst
					{
					DebugLocation(286, 25);
					COMMA48=(IToken)Match(input,COMMA,Follow._COMMA_in_field_inst_list1557); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_COMMA.Add(COMMA48);

					DebugLocation(286, 31);
					PushFollow(Follow._record_field_inst_in_field_inst_list1559);
					record_field_inst49=record_field_inst();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_record_field_inst.Add(record_field_inst49.Tree);

					}
					break;

				default:
					goto loop10;
				}
			}

			loop10:
				;

			} finally { DebugExitSubRule(10); }



			{
			// AST REWRITE
			// elements: record_field_inst
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 287:4: -> ^( FIELDS_INST ( record_field_inst )+ )
			{
				DebugLocation(287, 7);
				// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:287:7: ^( FIELDS_INST ( record_field_inst )+ )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(287, 9);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(FIELDS_INST, "FIELDS_INST"), root_1);

				DebugLocation(287, 21);
				if (!(stream_record_field_inst.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_record_field_inst.HasNext )
				{
					DebugLocation(287, 21);
					adaptor.AddChild(root_1, stream_record_field_inst.NextTree());

				}
				stream_record_field_inst.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("field_inst_list", 12);
			LeaveRule("field_inst_list", 12);
			LeaveRule_field_inst_list();
		}
		DebugLocation(288, 1);
		} finally { DebugExitRule(GrammarFileName, "field_inst_list"); }
		return retval;

	}
	// $ANTLR end "field_inst_list"

	partial void EnterRule_record_field_inst();
	partial void LeaveRule_record_field_inst();

	// $ANTLR start "record_field_inst"
	// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:290:1: record_field_inst : ID EQ expr -> ^( FIELD_INST ID expr ) ;
	[GrammarRule("record_field_inst")]
	private AstParserRuleReturnScope<object, IToken> record_field_inst()
	{
		EnterRule_record_field_inst();
		EnterRule("record_field_inst", 13);
		TraceIn("record_field_inst", 13);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID50 = default(IToken);
		IToken EQ51 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expr52 = default(AstParserRuleReturnScope<object, IToken>);

		object ID50_tree = default(object);
		object EQ51_tree = default(object);
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_EQ=new RewriteRuleITokenStream(adaptor,"token EQ");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		try { DebugEnterRule(GrammarFileName, "record_field_inst");
		DebugLocation(290, 1);
		try
		{
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:291:2: ( ID EQ expr -> ^( FIELD_INST ID expr ) )
			DebugEnterAlt(1);
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:291:5: ID EQ expr
			{
			DebugLocation(291, 5);
			ID50=(IToken)Match(input,ID,Follow._ID_in_record_field_inst1586); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(ID50);

			DebugLocation(291, 8);
			EQ51=(IToken)Match(input,EQ,Follow._EQ_in_record_field_inst1588); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_EQ.Add(EQ51);

			DebugLocation(291, 11);
			PushFollow(Follow._expr_in_record_field_inst1590);
			expr52=expr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expr.Add(expr52.Tree);


			{
			// AST REWRITE
			// elements: ID, expr
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 292:4: -> ^( FIELD_INST ID expr )
			{
				DebugLocation(292, 7);
				// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:292:7: ^( FIELD_INST ID expr )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(292, 9);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(FIELD_INST, "FIELD_INST"), root_1);

				DebugLocation(292, 20);
				adaptor.AddChild(root_1, stream_ID.NextNode());
				DebugLocation(292, 23);
				adaptor.AddChild(root_1, stream_expr.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("record_field_inst", 13);
			LeaveRule("record_field_inst", 13);
			LeaveRule_record_field_inst();
		}
		DebugLocation(293, 1);
		} finally { DebugExitRule(GrammarFileName, "record_field_inst"); }
		return retval;

	}
	// $ANTLR end "record_field_inst"

	partial void EnterRule_decl();
	partial void LeaveRule_decl();

	// $ANTLR start "decl"
	// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:295:1: decl : ( ( type_decl )+ -> ^( TYPE_DECL_SEQ ( type_decl )+ ) | var_decl | ( fun_decl )+ -> ^( FUN_DECL_SEQ ( fun_decl )+ ) );
	[GrammarRule("decl")]
	private AstParserRuleReturnScope<object, IToken> decl()
	{
		EnterRule_decl();
		EnterRule("decl", 14);
		TraceIn("decl", 14);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> type_decl53 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> var_decl54 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> fun_decl55 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_type_decl=new RewriteRuleSubtreeStream(adaptor,"rule type_decl");
		RewriteRuleSubtreeStream stream_fun_decl=new RewriteRuleSubtreeStream(adaptor,"rule fun_decl");
		try { DebugEnterRule(GrammarFileName, "decl");
		DebugLocation(295, 1);
		try
		{
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:296:2: ( ( type_decl )+ -> ^( TYPE_DECL_SEQ ( type_decl )+ ) | var_decl | ( fun_decl )+ -> ^( FUN_DECL_SEQ ( fun_decl )+ ) )
			int alt13=3;
			try { DebugEnterDecision(13, false);
			switch (input.LA(1))
			{
			case TYPEKEY:
				{
				alt13 = 1;
				}
				break;
			case VARKEY:
				{
				alt13 = 2;
				}
				break;
			case FUNCTIONKEY:
				{
				alt13 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 13, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(13); }
			switch (alt13)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:296:4: ( type_decl )+
				{
				DebugLocation(296, 4);
				// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:296:4: ( type_decl )+
				int cnt11=0;
				try { DebugEnterSubRule(11);
				while (true)
				{
					int alt11=2;
					try { DebugEnterDecision(11, false);
					int LA11_0 = input.LA(1);

					if ((LA11_0==TYPEKEY))
					{
						alt11 = 1;
					}


					} finally { DebugExitDecision(11); }
					switch (alt11)
					{
					case 1:
						DebugEnterAlt(1);
						// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:296:4: type_decl
						{
						DebugLocation(296, 4);
						PushFollow(Follow._type_decl_in_decl1615);
						type_decl53=type_decl();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_type_decl.Add(type_decl53.Tree);

						}
						break;

					default:
						if (cnt11 >= 1)
							goto loop11;

						if (state.backtracking>0) {state.failed=true; return retval;}
						EarlyExitException eee11 = new EarlyExitException( 11, input );
						DebugRecognitionException(eee11);
						throw eee11;
					}
					cnt11++;
				}
				loop11:
					;

				} finally { DebugExitSubRule(11); }



				{
				// AST REWRITE
				// elements: type_decl
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 297:4: -> ^( TYPE_DECL_SEQ ( type_decl )+ )
				{
					DebugLocation(297, 7);
					// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:297:7: ^( TYPE_DECL_SEQ ( type_decl )+ )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(297, 9);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(TYPE_DECL_SEQ, "TYPE_DECL_SEQ"), root_1);

					DebugLocation(297, 23);
					if (!(stream_type_decl.HasNext))
					{
						throw new RewriteEarlyExitException();
					}
					while ( stream_type_decl.HasNext )
					{
						DebugLocation(297, 23);
						adaptor.AddChild(root_1, stream_type_decl.NextTree());

					}
					stream_type_decl.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:298:4: var_decl
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(298, 4);
				PushFollow(Follow._var_decl_in_decl1633);
				var_decl54=var_decl();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, var_decl54.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:299:4: ( fun_decl )+
				{
				DebugLocation(299, 4);
				// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:299:4: ( fun_decl )+
				int cnt12=0;
				try { DebugEnterSubRule(12);
				while (true)
				{
					int alt12=2;
					try { DebugEnterDecision(12, false);
					int LA12_0 = input.LA(1);

					if ((LA12_0==FUNCTIONKEY))
					{
						alt12 = 1;
					}


					} finally { DebugExitDecision(12); }
					switch (alt12)
					{
					case 1:
						DebugEnterAlt(1);
						// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:299:4: fun_decl
						{
						DebugLocation(299, 4);
						PushFollow(Follow._fun_decl_in_decl1638);
						fun_decl55=fun_decl();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_fun_decl.Add(fun_decl55.Tree);

						}
						break;

					default:
						if (cnt12 >= 1)
							goto loop12;

						if (state.backtracking>0) {state.failed=true; return retval;}
						EarlyExitException eee12 = new EarlyExitException( 12, input );
						DebugRecognitionException(eee12);
						throw eee12;
					}
					cnt12++;
				}
				loop12:
					;

				} finally { DebugExitSubRule(12); }



				{
				// AST REWRITE
				// elements: fun_decl
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 300:4: -> ^( FUN_DECL_SEQ ( fun_decl )+ )
				{
					DebugLocation(300, 7);
					// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:300:7: ^( FUN_DECL_SEQ ( fun_decl )+ )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(300, 9);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(FUN_DECL_SEQ, "FUN_DECL_SEQ"), root_1);

					DebugLocation(300, 22);
					if (!(stream_fun_decl.HasNext))
					{
						throw new RewriteEarlyExitException();
					}
					while ( stream_fun_decl.HasNext )
					{
						DebugLocation(300, 22);
						adaptor.AddChild(root_1, stream_fun_decl.NextTree());

					}
					stream_fun_decl.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("decl", 14);
			LeaveRule("decl", 14);
			LeaveRule_decl();
		}
		DebugLocation(301, 1);
		} finally { DebugExitRule(GrammarFileName, "decl"); }
		return retval;

	}
	// $ANTLR end "decl"

	partial void EnterRule_type_decl();
	partial void LeaveRule_type_decl();

	// $ANTLR start "type_decl"
	// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:303:1: type_decl : TYPEKEY ID EQ type -> ^( TYPE_DECL ID type ) ;
	[GrammarRule("type_decl")]
	private AstParserRuleReturnScope<object, IToken> type_decl()
	{
		EnterRule_type_decl();
		EnterRule("type_decl", 15);
		TraceIn("type_decl", 15);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken TYPEKEY56 = default(IToken);
		IToken ID57 = default(IToken);
		IToken EQ58 = default(IToken);
		AstParserRuleReturnScope<object, IToken> type59 = default(AstParserRuleReturnScope<object, IToken>);

		object TYPEKEY56_tree = default(object);
		object ID57_tree = default(object);
		object EQ58_tree = default(object);
		RewriteRuleITokenStream stream_TYPEKEY=new RewriteRuleITokenStream(adaptor,"token TYPEKEY");
		RewriteRuleITokenStream stream_ID=new RewriteRuleITokenStream(adaptor,"token ID");
		RewriteRuleITokenStream stream_EQ=new RewriteRuleITokenStream(adaptor,"token EQ");
		RewriteRuleSubtreeStream stream_type=new RewriteRuleSubtreeStream(adaptor,"rule type");
		try { DebugEnterRule(GrammarFileName, "type_decl");
		DebugLocation(303, 1);
		try
		{
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:304:2: ( TYPEKEY ID EQ type -> ^( TYPE_DECL ID type ) )
			DebugEnterAlt(1);
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:304:4: TYPEKEY ID EQ type
			{
			DebugLocation(304, 4);
			TYPEKEY56=(IToken)Match(input,TYPEKEY,Follow._TYPEKEY_in_type_decl1662); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_TYPEKEY.Add(TYPEKEY56);

			DebugLocation(304, 12);
			ID57=(IToken)Match(input,ID,Follow._ID_in_type_decl1664); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ID.Add(ID57);

			DebugLocation(304, 15);
			EQ58=(IToken)Match(input,EQ,Follow._EQ_in_type_decl1666); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_EQ.Add(EQ58);

			DebugLocation(304, 18);
			PushFollow(Follow._type_in_type_decl1668);
			type59=type();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_type.Add(type59.Tree);


			{
			// AST REWRITE
			// elements: type, ID
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 305:4: -> ^( TYPE_DECL ID type )
			{
				DebugLocation(305, 7);
				// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:305:7: ^( TYPE_DECL ID type )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(305, 9);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(TYPE_DECL, "TYPE_DECL"), root_1);

				DebugLocation(305, 19);
				adaptor.AddChild(root_1, stream_ID.NextNode());
				DebugLocation(305, 22);
				adaptor.AddChild(root_1, stream_type.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("type_decl", 15);
			LeaveRule("type_decl", 15);
			LeaveRule_type_decl();
		}
		DebugLocation(306, 1);
		} finally { DebugExitRule(GrammarFileName, "type_decl"); }
		return retval;

	}
	// $ANTLR end "type_decl"

	partial void EnterRule_var_decl();
	partial void LeaveRule_var_decl();

	// $ANTLR start "var_decl"
	// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:308:1: var_decl : ( VARKEY type_id COLON type_id ASSIGN expr -> ^( VAR_DECL type_id type_id expr ) | VARKEY type_id ASSIGN expr -> ^( VAR_DECL type_id FILL_IN_TYPE expr ) );
	[GrammarRule("var_decl")]
	private AstParserRuleReturnScope<object, IToken> var_decl()
	{
		EnterRule_var_decl();
		EnterRule("var_decl", 16);
		TraceIn("var_decl", 16);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken VARKEY60 = default(IToken);
		IToken COLON62 = default(IToken);
		IToken ASSIGN64 = default(IToken);
		IToken VARKEY66 = default(IToken);
		IToken ASSIGN68 = default(IToken);
		AstParserRuleReturnScope<object, IToken> type_id61 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> type_id63 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expr65 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> type_id67 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expr69 = default(AstParserRuleReturnScope<object, IToken>);

		object VARKEY60_tree = default(object);
		object COLON62_tree = default(object);
		object ASSIGN64_tree = default(object);
		object VARKEY66_tree = default(object);
		object ASSIGN68_tree = default(object);
		RewriteRuleITokenStream stream_VARKEY=new RewriteRuleITokenStream(adaptor,"token VARKEY");
		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
		RewriteRuleITokenStream stream_ASSIGN=new RewriteRuleITokenStream(adaptor,"token ASSIGN");
		RewriteRuleSubtreeStream stream_type_id=new RewriteRuleSubtreeStream(adaptor,"rule type_id");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		try { DebugEnterRule(GrammarFileName, "var_decl");
		DebugLocation(308, 1);
		try
		{
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:309:2: ( VARKEY type_id COLON type_id ASSIGN expr -> ^( VAR_DECL type_id type_id expr ) | VARKEY type_id ASSIGN expr -> ^( VAR_DECL type_id FILL_IN_TYPE expr ) )
			int alt14=2;
			try { DebugEnterDecision(14, false);
			int LA14_0 = input.LA(1);

			if ((LA14_0==VARKEY))
			{
				int LA14_1 = input.LA(2);

				if ((LA14_1==ID||LA14_1==INTKEY||LA14_1==STRINGKEY))
				{
					int LA14_2 = input.LA(3);

					if ((LA14_2==COLON))
					{
						alt14 = 1;
					}
					else if ((LA14_2==ASSIGN))
					{
						alt14 = 2;
					}
					else
					{
						if (state.backtracking>0) {state.failed=true; return retval;}
						NoViableAltException nvae = new NoViableAltException("", 14, 2, input);
						DebugRecognitionException(nvae);
						throw nvae;
					}
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 14, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 14, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(14); }
			switch (alt14)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:309:4: VARKEY type_id COLON type_id ASSIGN expr
				{
				DebugLocation(309, 4);
				VARKEY60=(IToken)Match(input,VARKEY,Follow._VARKEY_in_var_decl1692); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_VARKEY.Add(VARKEY60);

				DebugLocation(309, 11);
				PushFollow(Follow._type_id_in_var_decl1694);
				type_id61=type_id();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_type_id.Add(type_id61.Tree);
				DebugLocation(309, 19);
				COLON62=(IToken)Match(input,COLON,Follow._COLON_in_var_decl1696); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_COLON.Add(COLON62);

				DebugLocation(309, 25);
				PushFollow(Follow._type_id_in_var_decl1698);
				type_id63=type_id();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_type_id.Add(type_id63.Tree);
				DebugLocation(309, 33);
				ASSIGN64=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_var_decl1700); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ASSIGN.Add(ASSIGN64);

				DebugLocation(309, 40);
				PushFollow(Follow._expr_in_var_decl1702);
				expr65=expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expr.Add(expr65.Tree);


				{
				// AST REWRITE
				// elements: type_id, expr, type_id
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 310:4: -> ^( VAR_DECL type_id type_id expr )
				{
					DebugLocation(310, 7);
					// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:310:7: ^( VAR_DECL type_id type_id expr )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(310, 9);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(VAR_DECL, "VAR_DECL"), root_1);

					DebugLocation(310, 18);
					adaptor.AddChild(root_1, stream_type_id.NextTree());
					DebugLocation(310, 26);
					adaptor.AddChild(root_1, stream_type_id.NextTree());
					DebugLocation(310, 34);
					adaptor.AddChild(root_1, stream_expr.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:311:4: VARKEY type_id ASSIGN expr
				{
				DebugLocation(311, 4);
				VARKEY66=(IToken)Match(input,VARKEY,Follow._VARKEY_in_var_decl1723); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_VARKEY.Add(VARKEY66);

				DebugLocation(311, 11);
				PushFollow(Follow._type_id_in_var_decl1725);
				type_id67=type_id();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_type_id.Add(type_id67.Tree);
				DebugLocation(311, 19);
				ASSIGN68=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_var_decl1727); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ASSIGN.Add(ASSIGN68);

				DebugLocation(311, 26);
				PushFollow(Follow._expr_in_var_decl1729);
				expr69=expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expr.Add(expr69.Tree);


				{
				// AST REWRITE
				// elements: expr, type_id
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 312:4: -> ^( VAR_DECL type_id FILL_IN_TYPE expr )
				{
					DebugLocation(312, 7);
					// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:312:7: ^( VAR_DECL type_id FILL_IN_TYPE expr )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(312, 9);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(VAR_DECL, "VAR_DECL"), root_1);

					DebugLocation(312, 18);
					adaptor.AddChild(root_1, stream_type_id.NextTree());
					DebugLocation(312, 26);
					adaptor.AddChild(root_1, (object)adaptor.Create(FILL_IN_TYPE, "FILL_IN_TYPE"));
					DebugLocation(312, 39);
					adaptor.AddChild(root_1, stream_expr.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("var_decl", 16);
			LeaveRule("var_decl", 16);
			LeaveRule_var_decl();
		}
		DebugLocation(313, 1);
		} finally { DebugExitRule(GrammarFileName, "var_decl"); }
		return retval;

	}
	// $ANTLR end "var_decl"

	partial void EnterRule_fun_decl();
	partial void LeaveRule_fun_decl();

	// $ANTLR start "fun_decl"
	// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:315:1: fun_decl : FUNCTIONKEY type_id LPAREN ( type_fields )? RPAREN ( COLON type_id )? EQ expr -> ^( FUN_DECL type_id ^( PARAM_DECL ( type_fields )? ) ^( FUN_TYPE_WRAPPER ( type_id )? ) expr ) ;
	[GrammarRule("fun_decl")]
	private AstParserRuleReturnScope<object, IToken> fun_decl()
	{
		EnterRule_fun_decl();
		EnterRule("fun_decl", 17);
		TraceIn("fun_decl", 17);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken FUNCTIONKEY70 = default(IToken);
		IToken LPAREN72 = default(IToken);
		IToken RPAREN74 = default(IToken);
		IToken COLON75 = default(IToken);
		IToken EQ77 = default(IToken);
		AstParserRuleReturnScope<object, IToken> type_id71 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> type_fields73 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> type_id76 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expr78 = default(AstParserRuleReturnScope<object, IToken>);

		object FUNCTIONKEY70_tree = default(object);
		object LPAREN72_tree = default(object);
		object RPAREN74_tree = default(object);
		object COLON75_tree = default(object);
		object EQ77_tree = default(object);
		RewriteRuleITokenStream stream_FUNCTIONKEY=new RewriteRuleITokenStream(adaptor,"token FUNCTIONKEY");
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleITokenStream stream_EQ=new RewriteRuleITokenStream(adaptor,"token EQ");
		RewriteRuleSubtreeStream stream_type_id=new RewriteRuleSubtreeStream(adaptor,"rule type_id");
		RewriteRuleSubtreeStream stream_type_fields=new RewriteRuleSubtreeStream(adaptor,"rule type_fields");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		try { DebugEnterRule(GrammarFileName, "fun_decl");
		DebugLocation(315, 1);
		try
		{
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:316:2: ( FUNCTIONKEY type_id LPAREN ( type_fields )? RPAREN ( COLON type_id )? EQ expr -> ^( FUN_DECL type_id ^( PARAM_DECL ( type_fields )? ) ^( FUN_TYPE_WRAPPER ( type_id )? ) expr ) )
			DebugEnterAlt(1);
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:316:4: FUNCTIONKEY type_id LPAREN ( type_fields )? RPAREN ( COLON type_id )? EQ expr
			{
			DebugLocation(316, 4);
			FUNCTIONKEY70=(IToken)Match(input,FUNCTIONKEY,Follow._FUNCTIONKEY_in_fun_decl1755); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_FUNCTIONKEY.Add(FUNCTIONKEY70);

			DebugLocation(316, 16);
			PushFollow(Follow._type_id_in_fun_decl1757);
			type_id71=type_id();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_type_id.Add(type_id71.Tree);
			DebugLocation(316, 24);
			LPAREN72=(IToken)Match(input,LPAREN,Follow._LPAREN_in_fun_decl1759); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LPAREN.Add(LPAREN72);

			DebugLocation(316, 31);
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:316:31: ( type_fields )?
			int alt15=2;
			try { DebugEnterSubRule(15);
			try { DebugEnterDecision(15, false);
			int LA15_0 = input.LA(1);

			if ((LA15_0==ID||LA15_0==INTKEY||LA15_0==STRINGKEY))
			{
				alt15 = 1;
			}
			} finally { DebugExitDecision(15); }
			switch (alt15)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:316:31: type_fields
				{
				DebugLocation(316, 31);
				PushFollow(Follow._type_fields_in_fun_decl1761);
				type_fields73=type_fields();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_type_fields.Add(type_fields73.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(15); }

			DebugLocation(316, 44);
			RPAREN74=(IToken)Match(input,RPAREN,Follow._RPAREN_in_fun_decl1764); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RPAREN.Add(RPAREN74);

			DebugLocation(316, 51);
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:316:51: ( COLON type_id )?
			int alt16=2;
			try { DebugEnterSubRule(16);
			try { DebugEnterDecision(16, false);
			int LA16_0 = input.LA(1);

			if ((LA16_0==COLON))
			{
				alt16 = 1;
			}
			} finally { DebugExitDecision(16); }
			switch (alt16)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:316:52: COLON type_id
				{
				DebugLocation(316, 52);
				COLON75=(IToken)Match(input,COLON,Follow._COLON_in_fun_decl1767); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_COLON.Add(COLON75);

				DebugLocation(316, 58);
				PushFollow(Follow._type_id_in_fun_decl1769);
				type_id76=type_id();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_type_id.Add(type_id76.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(16); }

			DebugLocation(316, 68);
			EQ77=(IToken)Match(input,EQ,Follow._EQ_in_fun_decl1773); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_EQ.Add(EQ77);

			DebugLocation(316, 71);
			PushFollow(Follow._expr_in_fun_decl1775);
			expr78=expr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expr.Add(expr78.Tree);


			{
			// AST REWRITE
			// elements: type_id, expr, type_id, type_fields
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 317:4: -> ^( FUN_DECL type_id ^( PARAM_DECL ( type_fields )? ) ^( FUN_TYPE_WRAPPER ( type_id )? ) expr )
			{
				DebugLocation(317, 7);
				// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:317:7: ^( FUN_DECL type_id ^( PARAM_DECL ( type_fields )? ) ^( FUN_TYPE_WRAPPER ( type_id )? ) expr )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(317, 9);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(FUN_DECL, "FUN_DECL"), root_1);

				DebugLocation(317, 18);
				adaptor.AddChild(root_1, stream_type_id.NextTree());
				DebugLocation(317, 26);
				// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:317:26: ^( PARAM_DECL ( type_fields )? )
				{
				object root_2 = (object)adaptor.Nil();
				DebugLocation(317, 28);
				root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(PARAM_DECL, "PARAM_DECL"), root_2);

				DebugLocation(317, 39);
				// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:317:39: ( type_fields )?
				if (stream_type_fields.HasNext)
				{
					DebugLocation(317, 39);
					adaptor.AddChild(root_2, stream_type_fields.NextTree());

				}
				stream_type_fields.Reset();

				adaptor.AddChild(root_1, root_2);
				}
				DebugLocation(317, 53);
				// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:317:53: ^( FUN_TYPE_WRAPPER ( type_id )? )
				{
				object root_2 = (object)adaptor.Nil();
				DebugLocation(317, 55);
				root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(FUN_TYPE_WRAPPER, "FUN_TYPE_WRAPPER"), root_2);

				DebugLocation(317, 72);
				// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:317:72: ( type_id )?
				if (stream_type_id.HasNext)
				{
					DebugLocation(317, 72);
					adaptor.AddChild(root_2, stream_type_id.NextTree());

				}
				stream_type_id.Reset();

				adaptor.AddChild(root_1, root_2);
				}
				DebugLocation(317, 82);
				adaptor.AddChild(root_1, stream_expr.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("fun_decl", 17);
			LeaveRule("fun_decl", 17);
			LeaveRule_fun_decl();
		}
		DebugLocation(318, 1);
		} finally { DebugExitRule(GrammarFileName, "fun_decl"); }
		return retval;

	}
	// $ANTLR end "fun_decl"

	partial void EnterRule_type_id();
	partial void LeaveRule_type_id();

	// $ANTLR start "type_id"
	// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:320:1: type_id : ( STRINGKEY | INTKEY | ID );
	[GrammarRule("type_id")]
	private AstParserRuleReturnScope<object, IToken> type_id()
	{
		EnterRule_type_id();
		EnterRule("type_id", 18);
		TraceIn("type_id", 18);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set79 = default(IToken);

		object set79_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "type_id");
		DebugLocation(320, 1);
		try
		{
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:321:2: ( STRINGKEY | INTKEY | ID )
			DebugEnterAlt(1);
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(321, 2);

			set79=(IToken)input.LT(1);
			if (input.LA(1)==ID||input.LA(1)==INTKEY||input.LA(1)==STRINGKEY)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(set79));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("type_id", 18);
			LeaveRule("type_id", 18);
			LeaveRule_type_id();
		}
		DebugLocation(324, 1);
		} finally { DebugExitRule(GrammarFileName, "type_id"); }
		return retval;

	}
	// $ANTLR end "type_id"

	partial void EnterRule_type();
	partial void LeaveRule_type();

	// $ANTLR start "type"
	// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:326:1: type : ( type_id -> ^( ALIAS_DECL type_id ) | array_decl | record_decl );
	[GrammarRule("type")]
	private AstParserRuleReturnScope<object, IToken> type()
	{
		EnterRule_type();
		EnterRule("type", 19);
		TraceIn("type", 19);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> type_id80 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> array_decl81 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> record_decl82 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_type_id=new RewriteRuleSubtreeStream(adaptor,"rule type_id");
		try { DebugEnterRule(GrammarFileName, "type");
		DebugLocation(326, 1);
		try
		{
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:327:2: ( type_id -> ^( ALIAS_DECL type_id ) | array_decl | record_decl )
			int alt17=3;
			try { DebugEnterDecision(17, false);
			switch (input.LA(1))
			{
			case ID:
			case INTKEY:
			case STRINGKEY:
				{
				alt17 = 1;
				}
				break;
			case ARRAYKEY:
				{
				alt17 = 2;
				}
				break;
			case LKEY:
				{
				alt17 = 3;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 17, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(17); }
			switch (alt17)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:327:4: type_id
				{
				DebugLocation(327, 4);
				PushFollow(Follow._type_id_in_type1834);
				type_id80=type_id();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_type_id.Add(type_id80.Tree);


				{
				// AST REWRITE
				// elements: type_id
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 328:13: -> ^( ALIAS_DECL type_id )
				{
					DebugLocation(328, 16);
					// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:328:16: ^( ALIAS_DECL type_id )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(328, 18);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ALIAS_DECL, "ALIAS_DECL"), root_1);

					DebugLocation(328, 29);
					adaptor.AddChild(root_1, stream_type_id.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:329:4: array_decl
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(329, 4);
				PushFollow(Follow._array_decl_in_type1859);
				array_decl81=array_decl();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, array_decl81.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:330:4: record_decl
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(330, 4);
				PushFollow(Follow._record_decl_in_type1865);
				record_decl82=record_decl();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, record_decl82.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("type", 19);
			LeaveRule("type", 19);
			LeaveRule_type();
		}
		DebugLocation(331, 1);
		} finally { DebugExitRule(GrammarFileName, "type"); }
		return retval;

	}
	// $ANTLR end "type"

	partial void EnterRule_record_decl();
	partial void LeaveRule_record_decl();

	// $ANTLR start "record_decl"
	// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:333:1: record_decl : LKEY ( type_fields )? RKEY -> ^( RECORD_DECL ( type_fields )? ) ;
	[GrammarRule("record_decl")]
	private AstParserRuleReturnScope<object, IToken> record_decl()
	{
		EnterRule_record_decl();
		EnterRule("record_decl", 20);
		TraceIn("record_decl", 20);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken LKEY83 = default(IToken);
		IToken RKEY85 = default(IToken);
		AstParserRuleReturnScope<object, IToken> type_fields84 = default(AstParserRuleReturnScope<object, IToken>);

		object LKEY83_tree = default(object);
		object RKEY85_tree = default(object);
		RewriteRuleITokenStream stream_LKEY=new RewriteRuleITokenStream(adaptor,"token LKEY");
		RewriteRuleITokenStream stream_RKEY=new RewriteRuleITokenStream(adaptor,"token RKEY");
		RewriteRuleSubtreeStream stream_type_fields=new RewriteRuleSubtreeStream(adaptor,"rule type_fields");
		try { DebugEnterRule(GrammarFileName, "record_decl");
		DebugLocation(333, 1);
		try
		{
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:334:2: ( LKEY ( type_fields )? RKEY -> ^( RECORD_DECL ( type_fields )? ) )
			DebugEnterAlt(1);
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:334:4: LKEY ( type_fields )? RKEY
			{
			DebugLocation(334, 4);
			LKEY83=(IToken)Match(input,LKEY,Follow._LKEY_in_record_decl1876); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LKEY.Add(LKEY83);

			DebugLocation(334, 9);
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:334:9: ( type_fields )?
			int alt18=2;
			try { DebugEnterSubRule(18);
			try { DebugEnterDecision(18, false);
			int LA18_0 = input.LA(1);

			if ((LA18_0==ID||LA18_0==INTKEY||LA18_0==STRINGKEY))
			{
				alt18 = 1;
			}
			} finally { DebugExitDecision(18); }
			switch (alt18)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:334:9: type_fields
				{
				DebugLocation(334, 9);
				PushFollow(Follow._type_fields_in_record_decl1878);
				type_fields84=type_fields();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_type_fields.Add(type_fields84.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(18); }

			DebugLocation(334, 22);
			RKEY85=(IToken)Match(input,RKEY,Follow._RKEY_in_record_decl1881); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RKEY.Add(RKEY85);



			{
			// AST REWRITE
			// elements: type_fields
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 335:4: -> ^( RECORD_DECL ( type_fields )? )
			{
				DebugLocation(335, 7);
				// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:335:7: ^( RECORD_DECL ( type_fields )? )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(335, 9);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(RECORD_DECL, "RECORD_DECL"), root_1);

				DebugLocation(335, 21);
				// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:335:21: ( type_fields )?
				if (stream_type_fields.HasNext)
				{
					DebugLocation(335, 21);
					adaptor.AddChild(root_1, stream_type_fields.NextTree());

				}
				stream_type_fields.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("record_decl", 20);
			LeaveRule("record_decl", 20);
			LeaveRule_record_decl();
		}
		DebugLocation(336, 1);
		} finally { DebugExitRule(GrammarFileName, "record_decl"); }
		return retval;

	}
	// $ANTLR end "record_decl"

	partial void EnterRule_array_decl();
	partial void LeaveRule_array_decl();

	// $ANTLR start "array_decl"
	// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:338:1: array_decl : ARRAYKEY OFKEY type_id -> ^( ARRAY_DECL type_id ) ;
	[GrammarRule("array_decl")]
	private AstParserRuleReturnScope<object, IToken> array_decl()
	{
		EnterRule_array_decl();
		EnterRule("array_decl", 21);
		TraceIn("array_decl", 21);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ARRAYKEY86 = default(IToken);
		IToken OFKEY87 = default(IToken);
		AstParserRuleReturnScope<object, IToken> type_id88 = default(AstParserRuleReturnScope<object, IToken>);

		object ARRAYKEY86_tree = default(object);
		object OFKEY87_tree = default(object);
		RewriteRuleITokenStream stream_ARRAYKEY=new RewriteRuleITokenStream(adaptor,"token ARRAYKEY");
		RewriteRuleITokenStream stream_OFKEY=new RewriteRuleITokenStream(adaptor,"token OFKEY");
		RewriteRuleSubtreeStream stream_type_id=new RewriteRuleSubtreeStream(adaptor,"rule type_id");
		try { DebugEnterRule(GrammarFileName, "array_decl");
		DebugLocation(338, 1);
		try
		{
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:339:2: ( ARRAYKEY OFKEY type_id -> ^( ARRAY_DECL type_id ) )
			DebugEnterAlt(1);
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:339:4: ARRAYKEY OFKEY type_id
			{
			DebugLocation(339, 4);
			ARRAYKEY86=(IToken)Match(input,ARRAYKEY,Follow._ARRAYKEY_in_array_decl1904); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ARRAYKEY.Add(ARRAYKEY86);

			DebugLocation(339, 13);
			OFKEY87=(IToken)Match(input,OFKEY,Follow._OFKEY_in_array_decl1906); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_OFKEY.Add(OFKEY87);

			DebugLocation(339, 19);
			PushFollow(Follow._type_id_in_array_decl1908);
			type_id88=type_id();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_type_id.Add(type_id88.Tree);


			{
			// AST REWRITE
			// elements: type_id
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 340:4: -> ^( ARRAY_DECL type_id )
			{
				DebugLocation(340, 7);
				// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:340:7: ^( ARRAY_DECL type_id )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(340, 9);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ARRAY_DECL, "ARRAY_DECL"), root_1);

				DebugLocation(340, 20);
				adaptor.AddChild(root_1, stream_type_id.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("array_decl", 21);
			LeaveRule("array_decl", 21);
			LeaveRule_array_decl();
		}
		DebugLocation(341, 1);
		} finally { DebugExitRule(GrammarFileName, "array_decl"); }
		return retval;

	}
	// $ANTLR end "array_decl"

	partial void EnterRule_type_fields();
	partial void LeaveRule_type_fields();

	// $ANTLR start "type_fields"
	// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:343:1: type_fields : type_field ( COMMA type_field )* -> ( type_field )+ ;
	[GrammarRule("type_fields")]
	private AstParserRuleReturnScope<object, IToken> type_fields()
	{
		EnterRule_type_fields();
		EnterRule("type_fields", 22);
		TraceIn("type_fields", 22);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken COMMA90 = default(IToken);
		AstParserRuleReturnScope<object, IToken> type_field89 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> type_field91 = default(AstParserRuleReturnScope<object, IToken>);

		object COMMA90_tree = default(object);
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_type_field=new RewriteRuleSubtreeStream(adaptor,"rule type_field");
		try { DebugEnterRule(GrammarFileName, "type_fields");
		DebugLocation(343, 1);
		try
		{
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:344:2: ( type_field ( COMMA type_field )* -> ( type_field )+ )
			DebugEnterAlt(1);
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:344:4: type_field ( COMMA type_field )*
			{
			DebugLocation(344, 4);
			PushFollow(Follow._type_field_in_type_fields1931);
			type_field89=type_field();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_type_field.Add(type_field89.Tree);
			DebugLocation(344, 15);
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:344:15: ( COMMA type_field )*
			try { DebugEnterSubRule(19);
			while (true)
			{
				int alt19=2;
				try { DebugEnterDecision(19, false);
				int LA19_0 = input.LA(1);

				if ((LA19_0==COMMA))
				{
					alt19 = 1;
				}


				} finally { DebugExitDecision(19); }
				switch ( alt19 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:344:16: COMMA type_field
					{
					DebugLocation(344, 16);
					COMMA90=(IToken)Match(input,COMMA,Follow._COMMA_in_type_fields1934); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_COMMA.Add(COMMA90);

					DebugLocation(344, 22);
					PushFollow(Follow._type_field_in_type_fields1936);
					type_field91=type_field();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_type_field.Add(type_field91.Tree);

					}
					break;

				default:
					goto loop19;
				}
			}

			loop19:
				;

			} finally { DebugExitSubRule(19); }



			{
			// AST REWRITE
			// elements: type_field
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 345:4: -> ( type_field )+
			{
				DebugLocation(345, 7);
				if (!(stream_type_field.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_type_field.HasNext )
				{
					DebugLocation(345, 7);
					adaptor.AddChild(root_0, stream_type_field.NextTree());

				}
				stream_type_field.Reset();

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("type_fields", 22);
			LeaveRule("type_fields", 22);
			LeaveRule_type_fields();
		}
		DebugLocation(346, 1);
		} finally { DebugExitRule(GrammarFileName, "type_fields"); }
		return retval;

	}
	// $ANTLR end "type_fields"

	partial void EnterRule_type_field();
	partial void LeaveRule_type_field();

	// $ANTLR start "type_field"
	// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:348:1: type_field : type_id COLON type_id -> ^( TYPE_FIELD type_id type_id ) ;
	[GrammarRule("type_field")]
	private AstParserRuleReturnScope<object, IToken> type_field()
	{
		EnterRule_type_field();
		EnterRule("type_field", 23);
		TraceIn("type_field", 23);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken COLON93 = default(IToken);
		AstParserRuleReturnScope<object, IToken> type_id92 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> type_id94 = default(AstParserRuleReturnScope<object, IToken>);

		object COLON93_tree = default(object);
		RewriteRuleITokenStream stream_COLON=new RewriteRuleITokenStream(adaptor,"token COLON");
		RewriteRuleSubtreeStream stream_type_id=new RewriteRuleSubtreeStream(adaptor,"rule type_id");
		try { DebugEnterRule(GrammarFileName, "type_field");
		DebugLocation(348, 1);
		try
		{
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:349:2: ( type_id COLON type_id -> ^( TYPE_FIELD type_id type_id ) )
			DebugEnterAlt(1);
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:349:4: type_id COLON type_id
			{
			DebugLocation(349, 4);
			PushFollow(Follow._type_id_in_type_field1957);
			type_id92=type_id();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_type_id.Add(type_id92.Tree);
			DebugLocation(349, 12);
			COLON93=(IToken)Match(input,COLON,Follow._COLON_in_type_field1959); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_COLON.Add(COLON93);

			DebugLocation(349, 18);
			PushFollow(Follow._type_id_in_type_field1961);
			type_id94=type_id();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_type_id.Add(type_id94.Tree);


			{
			// AST REWRITE
			// elements: type_id, type_id
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 350:4: -> ^( TYPE_FIELD type_id type_id )
			{
				DebugLocation(350, 7);
				// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:350:7: ^( TYPE_FIELD type_id type_id )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(350, 9);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(TYPE_FIELD, "TYPE_FIELD"), root_1);

				DebugLocation(350, 20);
				adaptor.AddChild(root_1, stream_type_id.NextTree());
				DebugLocation(350, 28);
				adaptor.AddChild(root_1, stream_type_id.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("type_field", 23);
			LeaveRule("type_field", 23);
			LeaveRule_type_field();
		}
		DebugLocation(351, 1);
		} finally { DebugExitRule(GrammarFileName, "type_field"); }
		return retval;

	}
	// $ANTLR end "type_field"

	partial void EnterRule_atom();
	partial void LeaveRule_atom();

	// $ANTLR start "atom"
	// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:353:1: atom : ( MINUS atom -> ^( NEG atom ) | constant_value | lvalue | funcall | if_then_expr | for_expr | let_expr | LPAREN expr_seq RPAREN -> expr_seq );
	[GrammarRule("atom")]
	private AstParserRuleReturnScope<object, IToken> atom()
	{
		EnterRule_atom();
		EnterRule("atom", 24);
		TraceIn("atom", 24);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken MINUS95 = default(IToken);
		IToken LPAREN103 = default(IToken);
		IToken RPAREN105 = default(IToken);
		AstParserRuleReturnScope<object, IToken> atom96 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> constant_value97 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> lvalue98 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> funcall99 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> if_then_expr100 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> for_expr101 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> let_expr102 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expr_seq104 = default(AstParserRuleReturnScope<object, IToken>);

		object MINUS95_tree = default(object);
		object LPAREN103_tree = default(object);
		object RPAREN105_tree = default(object);
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleITokenStream stream_MINUS=new RewriteRuleITokenStream(adaptor,"token MINUS");
		RewriteRuleSubtreeStream stream_expr_seq=new RewriteRuleSubtreeStream(adaptor,"rule expr_seq");
		RewriteRuleSubtreeStream stream_atom=new RewriteRuleSubtreeStream(adaptor,"rule atom");
		try { DebugEnterRule(GrammarFileName, "atom");
		DebugLocation(353, 1);
		try
		{
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:354:2: ( MINUS atom -> ^( NEG atom ) | constant_value | lvalue | funcall | if_then_expr | for_expr | let_expr | LPAREN expr_seq RPAREN -> expr_seq )
			int alt20=8;
			try { DebugEnterDecision(20, false);
			switch (input.LA(1))
			{
			case MINUS:
				{
				alt20 = 1;
				}
				break;
			case INT:
			case NILKEY:
			case STRING:
				{
				alt20 = 2;
				}
				break;
			case ID:
			case INTKEY:
			case STRINGKEY:
				{
				int LA20_3 = input.LA(2);

				if ((LA20_3==EOF||LA20_3==AND||LA20_3==COMMA||(LA20_3>=DIV && LA20_3<=ENDKEY)||LA20_3==EQ||LA20_3==FUNCTIONKEY||(LA20_3>=GT && LA20_3<=GTEQ)||LA20_3==INKEY||LA20_3==LBRACKET||(LA20_3>=LT && LA20_3<=MULT)||LA20_3==NOTEQ||LA20_3==OR||LA20_3==PLUS||LA20_3==RBRACKET||(LA20_3>=RKEY && LA20_3<=SEMI)||(LA20_3>=THENKEY && LA20_3<=TOKEY)||LA20_3==TYPEKEY||LA20_3==VARKEY))
				{
					alt20 = 3;
				}
				else if ((LA20_3==LPAREN))
				{
					alt20 = 4;
				}
				else
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 20, 3, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case IFKEY:
				{
				alt20 = 5;
				}
				break;
			case FORKEY:
				{
				alt20 = 6;
				}
				break;
			case LETKEY:
				{
				alt20 = 7;
				}
				break;
			case LPAREN:
				{
				alt20 = 8;
				}
				break;
			default:
				{
					if (state.backtracking>0) {state.failed=true; return retval;}
					NoViableAltException nvae = new NoViableAltException("", 20, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(20); }
			switch (alt20)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:354:4: MINUS atom
				{
				DebugLocation(354, 4);
				MINUS95=(IToken)Match(input,MINUS,Follow._MINUS_in_atom1986); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_MINUS.Add(MINUS95);

				DebugLocation(354, 10);
				PushFollow(Follow._atom_in_atom1988);
				atom96=atom();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_atom.Add(atom96.Tree);


				{
				// AST REWRITE
				// elements: atom
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 355:13: -> ^( NEG atom )
				{
					DebugLocation(355, 16);
					// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:355:16: ^( NEG atom )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(355, 18);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(NEG, "NEG"), root_1);

					DebugLocation(355, 22);
					adaptor.AddChild(root_1, stream_atom.NextTree());

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:356:4: constant_value
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(356, 4);
				PushFollow(Follow._constant_value_in_atom2013);
				constant_value97=constant_value();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, constant_value97.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:357:4: lvalue
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(357, 4);
				PushFollow(Follow._lvalue_in_atom2018);
				lvalue98=lvalue();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, lvalue98.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:358:4: funcall
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(358, 4);
				PushFollow(Follow._funcall_in_atom2023);
				funcall99=funcall();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, funcall99.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:359:4: if_then_expr
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(359, 4);
				PushFollow(Follow._if_then_expr_in_atom2028);
				if_then_expr100=if_then_expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, if_then_expr100.Tree);

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:360:4: for_expr
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(360, 4);
				PushFollow(Follow._for_expr_in_atom2033);
				for_expr101=for_expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, for_expr101.Tree);

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:361:4: let_expr
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(361, 4);
				PushFollow(Follow._let_expr_in_atom2038);
				let_expr102=let_expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) adaptor.AddChild(root_0, let_expr102.Tree);

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:362:4: LPAREN expr_seq RPAREN
				{
				DebugLocation(362, 4);
				LPAREN103=(IToken)Match(input,LPAREN,Follow._LPAREN_in_atom2043); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LPAREN.Add(LPAREN103);

				DebugLocation(362, 11);
				PushFollow(Follow._expr_seq_in_atom2045);
				expr_seq104=expr_seq();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expr_seq.Add(expr_seq104.Tree);
				DebugLocation(362, 20);
				RPAREN105=(IToken)Match(input,RPAREN,Follow._RPAREN_in_atom2047); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_RPAREN.Add(RPAREN105);



				{
				// AST REWRITE
				// elements: expr_seq
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 363:4: -> expr_seq
				{
					DebugLocation(363, 7);
					adaptor.AddChild(root_0, stream_expr_seq.NextTree());

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("atom", 24);
			LeaveRule("atom", 24);
			LeaveRule_atom();
		}
		DebugLocation(364, 1);
		} finally { DebugExitRule(GrammarFileName, "atom"); }
		return retval;

	}
	// $ANTLR end "atom"

	partial void EnterRule_constant_value();
	partial void LeaveRule_constant_value();

	// $ANTLR start "constant_value"
	// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:366:1: constant_value : ( STRING | INT | NILKEY );
	[GrammarRule("constant_value")]
	private AstParserRuleReturnScope<object, IToken> constant_value()
	{
		EnterRule_constant_value();
		EnterRule("constant_value", 25);
		TraceIn("constant_value", 25);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set106 = default(IToken);

		object set106_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "constant_value");
		DebugLocation(366, 1);
		try
		{
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:367:2: ( STRING | INT | NILKEY )
			DebugEnterAlt(1);
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(367, 2);

			set106=(IToken)input.LT(1);
			if (input.LA(1)==INT||input.LA(1)==NILKEY||input.LA(1)==STRING)
			{
				input.Consume();
				if (state.backtracking == 0) adaptor.AddChild(root_0, (object)adaptor.Create(set106));
				state.errorRecovery=false;state.failed=false;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("constant_value", 25);
			LeaveRule("constant_value", 25);
			LeaveRule_constant_value();
		}
		DebugLocation(370, 1);
		} finally { DebugExitRule(GrammarFileName, "constant_value"); }
		return retval;

	}
	// $ANTLR end "constant_value"

	partial void EnterRule_if_then_expr();
	partial void LeaveRule_if_then_expr();

	// $ANTLR start "if_then_expr"
	// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:372:1: if_then_expr : IFKEY conditional= disjunction_expr THENKEY then_expr= expr ( ELSEKEY else_expr= expr )? -> ^( IF $conditional $then_expr ( $else_expr)? ) ;
	[GrammarRule("if_then_expr")]
	private AstParserRuleReturnScope<object, IToken> if_then_expr()
	{
		EnterRule_if_then_expr();
		EnterRule("if_then_expr", 26);
		TraceIn("if_then_expr", 26);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken IFKEY107 = default(IToken);
		IToken THENKEY108 = default(IToken);
		IToken ELSEKEY109 = default(IToken);
		AstParserRuleReturnScope<object, IToken> conditional = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> then_expr = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> else_expr = default(AstParserRuleReturnScope<object, IToken>);

		object IFKEY107_tree = default(object);
		object THENKEY108_tree = default(object);
		object ELSEKEY109_tree = default(object);
		RewriteRuleITokenStream stream_ELSEKEY=new RewriteRuleITokenStream(adaptor,"token ELSEKEY");
		RewriteRuleITokenStream stream_IFKEY=new RewriteRuleITokenStream(adaptor,"token IFKEY");
		RewriteRuleITokenStream stream_THENKEY=new RewriteRuleITokenStream(adaptor,"token THENKEY");
		RewriteRuleSubtreeStream stream_disjunction_expr=new RewriteRuleSubtreeStream(adaptor,"rule disjunction_expr");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		try { DebugEnterRule(GrammarFileName, "if_then_expr");
		DebugLocation(372, 1);
		try
		{
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:373:2: ( IFKEY conditional= disjunction_expr THENKEY then_expr= expr ( ELSEKEY else_expr= expr )? -> ^( IF $conditional $then_expr ( $else_expr)? ) )
			DebugEnterAlt(1);
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:373:4: IFKEY conditional= disjunction_expr THENKEY then_expr= expr ( ELSEKEY else_expr= expr )?
			{
			DebugLocation(373, 4);
			IFKEY107=(IToken)Match(input,IFKEY,Follow._IFKEY_in_if_then_expr2086); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_IFKEY.Add(IFKEY107);

			DebugLocation(373, 21);
			PushFollow(Follow._disjunction_expr_in_if_then_expr2090);
			conditional=disjunction_expr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_disjunction_expr.Add(conditional.Tree);
			DebugLocation(373, 39);
			THENKEY108=(IToken)Match(input,THENKEY,Follow._THENKEY_in_if_then_expr2092); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_THENKEY.Add(THENKEY108);

			DebugLocation(373, 56);
			PushFollow(Follow._expr_in_if_then_expr2096);
			then_expr=expr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expr.Add(then_expr.Tree);
			DebugLocation(373, 62);
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:373:62: ( ELSEKEY else_expr= expr )?
			int alt21=2;
			try { DebugEnterSubRule(21);
			try { DebugEnterDecision(21, false);
			int LA21_0 = input.LA(1);

			if ((LA21_0==ELSEKEY))
			{
				alt21 = 1;
			}
			} finally { DebugExitDecision(21); }
			switch (alt21)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:373:63: ELSEKEY else_expr= expr
				{
				DebugLocation(373, 63);
				ELSEKEY109=(IToken)Match(input,ELSEKEY,Follow._ELSEKEY_in_if_then_expr2099); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_ELSEKEY.Add(ELSEKEY109);

				DebugLocation(373, 80);
				PushFollow(Follow._expr_in_if_then_expr2103);
				else_expr=expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expr.Add(else_expr.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(21); }



			{
			// AST REWRITE
			// elements: else_expr, conditional, then_expr
			// token labels: 
			// rule labels: else_expr, conditional, then_expr, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_else_expr=new RewriteRuleSubtreeStream(adaptor,"rule else_expr",else_expr!=null?else_expr.Tree:null);
			RewriteRuleSubtreeStream stream_conditional=new RewriteRuleSubtreeStream(adaptor,"rule conditional",conditional!=null?conditional.Tree:null);
			RewriteRuleSubtreeStream stream_then_expr=new RewriteRuleSubtreeStream(adaptor,"rule then_expr",then_expr!=null?then_expr.Tree:null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 374:4: -> ^( IF $conditional $then_expr ( $else_expr)? )
			{
				DebugLocation(374, 7);
				// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:374:7: ^( IF $conditional $then_expr ( $else_expr)? )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(374, 9);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(IF, "IF"), root_1);

				DebugLocation(374, 13);
				adaptor.AddChild(root_1, stream_conditional.NextTree());
				DebugLocation(374, 26);
				adaptor.AddChild(root_1, stream_then_expr.NextTree());
				DebugLocation(374, 37);
				// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:374:37: ( $else_expr)?
				if (stream_else_expr.HasNext)
				{
					DebugLocation(374, 37);
					adaptor.AddChild(root_1, stream_else_expr.NextTree());

				}
				stream_else_expr.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("if_then_expr", 26);
			LeaveRule("if_then_expr", 26);
			LeaveRule_if_then_expr();
		}
		DebugLocation(375, 1);
		} finally { DebugExitRule(GrammarFileName, "if_then_expr"); }
		return retval;

	}
	// $ANTLR end "if_then_expr"

	partial void EnterRule_while_stat();
	partial void LeaveRule_while_stat();

	// $ANTLR start "while_stat"
	// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:377:1: while_stat : WHILEKEY cond= disjunction_expr DOKEY do_expr= expr -> ^( WHILE $cond $do_expr) ;
	[GrammarRule("while_stat")]
	private AstParserRuleReturnScope<object, IToken> while_stat()
	{
		EnterRule_while_stat();
		EnterRule("while_stat", 27);
		TraceIn("while_stat", 27);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken WHILEKEY110 = default(IToken);
		IToken DOKEY111 = default(IToken);
		AstParserRuleReturnScope<object, IToken> cond = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> do_expr = default(AstParserRuleReturnScope<object, IToken>);

		object WHILEKEY110_tree = default(object);
		object DOKEY111_tree = default(object);
		RewriteRuleITokenStream stream_WHILEKEY=new RewriteRuleITokenStream(adaptor,"token WHILEKEY");
		RewriteRuleITokenStream stream_DOKEY=new RewriteRuleITokenStream(adaptor,"token DOKEY");
		RewriteRuleSubtreeStream stream_disjunction_expr=new RewriteRuleSubtreeStream(adaptor,"rule disjunction_expr");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		try { DebugEnterRule(GrammarFileName, "while_stat");
		DebugLocation(377, 1);
		try
		{
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:378:2: ( WHILEKEY cond= disjunction_expr DOKEY do_expr= expr -> ^( WHILE $cond $do_expr) )
			DebugEnterAlt(1);
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:378:4: WHILEKEY cond= disjunction_expr DOKEY do_expr= expr
			{
			DebugLocation(378, 4);
			WHILEKEY110=(IToken)Match(input,WHILEKEY,Follow._WHILEKEY_in_while_stat2136); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_WHILEKEY.Add(WHILEKEY110);

			DebugLocation(378, 17);
			PushFollow(Follow._disjunction_expr_in_while_stat2140);
			cond=disjunction_expr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_disjunction_expr.Add(cond.Tree);
			DebugLocation(378, 35);
			DOKEY111=(IToken)Match(input,DOKEY,Follow._DOKEY_in_while_stat2142); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_DOKEY.Add(DOKEY111);

			DebugLocation(378, 48);
			PushFollow(Follow._expr_in_while_stat2146);
			do_expr=expr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expr.Add(do_expr.Tree);


			{
			// AST REWRITE
			// elements: cond, do_expr
			// token labels: 
			// rule labels: do_expr, cond, retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_do_expr=new RewriteRuleSubtreeStream(adaptor,"rule do_expr",do_expr!=null?do_expr.Tree:null);
			RewriteRuleSubtreeStream stream_cond=new RewriteRuleSubtreeStream(adaptor,"rule cond",cond!=null?cond.Tree:null);
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 379:4: -> ^( WHILE $cond $do_expr)
			{
				DebugLocation(379, 7);
				// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:379:7: ^( WHILE $cond $do_expr)
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(379, 9);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(WHILE, "WHILE"), root_1);

				DebugLocation(379, 16);
				adaptor.AddChild(root_1, stream_cond.NextTree());
				DebugLocation(379, 22);
				adaptor.AddChild(root_1, stream_do_expr.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("while_stat", 27);
			LeaveRule("while_stat", 27);
			LeaveRule_while_stat();
		}
		DebugLocation(380, 1);
		} finally { DebugExitRule(GrammarFileName, "while_stat"); }
		return retval;

	}
	// $ANTLR end "while_stat"

	partial void EnterRule_let_expr();
	partial void LeaveRule_let_expr();

	// $ANTLR start "let_expr"
	// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:382:1: let_expr : LETKEY ( decl )+ INKEY expr_seq ENDKEY -> ^( LET ^( DECL_BLOCK ( decl )+ ) expr_seq ) ;
	[GrammarRule("let_expr")]
	private AstParserRuleReturnScope<object, IToken> let_expr()
	{
		EnterRule_let_expr();
		EnterRule("let_expr", 28);
		TraceIn("let_expr", 28);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken LETKEY112 = default(IToken);
		IToken INKEY114 = default(IToken);
		IToken ENDKEY116 = default(IToken);
		AstParserRuleReturnScope<object, IToken> decl113 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expr_seq115 = default(AstParserRuleReturnScope<object, IToken>);

		object LETKEY112_tree = default(object);
		object INKEY114_tree = default(object);
		object ENDKEY116_tree = default(object);
		RewriteRuleITokenStream stream_INKEY=new RewriteRuleITokenStream(adaptor,"token INKEY");
		RewriteRuleITokenStream stream_LETKEY=new RewriteRuleITokenStream(adaptor,"token LETKEY");
		RewriteRuleITokenStream stream_ENDKEY=new RewriteRuleITokenStream(adaptor,"token ENDKEY");
		RewriteRuleSubtreeStream stream_expr_seq=new RewriteRuleSubtreeStream(adaptor,"rule expr_seq");
		RewriteRuleSubtreeStream stream_decl=new RewriteRuleSubtreeStream(adaptor,"rule decl");
		try { DebugEnterRule(GrammarFileName, "let_expr");
		DebugLocation(382, 1);
		try
		{
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:383:2: ( LETKEY ( decl )+ INKEY expr_seq ENDKEY -> ^( LET ^( DECL_BLOCK ( decl )+ ) expr_seq ) )
			DebugEnterAlt(1);
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:383:4: LETKEY ( decl )+ INKEY expr_seq ENDKEY
			{
			DebugLocation(383, 4);
			LETKEY112=(IToken)Match(input,LETKEY,Follow._LETKEY_in_let_expr2172); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LETKEY.Add(LETKEY112);

			DebugLocation(383, 11);
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:383:11: ( decl )+
			int cnt22=0;
			try { DebugEnterSubRule(22);
			while (true)
			{
				int alt22=2;
				try { DebugEnterDecision(22, false);
				int LA22_0 = input.LA(1);

				if ((LA22_0==FUNCTIONKEY||LA22_0==TYPEKEY||LA22_0==VARKEY))
				{
					alt22 = 1;
				}


				} finally { DebugExitDecision(22); }
				switch (alt22)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:383:11: decl
					{
					DebugLocation(383, 11);
					PushFollow(Follow._decl_in_let_expr2174);
					decl113=decl();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_decl.Add(decl113.Tree);

					}
					break;

				default:
					if (cnt22 >= 1)
						goto loop22;

					if (state.backtracking>0) {state.failed=true; return retval;}
					EarlyExitException eee22 = new EarlyExitException( 22, input );
					DebugRecognitionException(eee22);
					throw eee22;
				}
				cnt22++;
			}
			loop22:
				;

			} finally { DebugExitSubRule(22); }

			DebugLocation(383, 17);
			INKEY114=(IToken)Match(input,INKEY,Follow._INKEY_in_let_expr2177); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_INKEY.Add(INKEY114);

			DebugLocation(383, 23);
			PushFollow(Follow._expr_seq_in_let_expr2179);
			expr_seq115=expr_seq();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expr_seq.Add(expr_seq115.Tree);
			DebugLocation(383, 32);
			ENDKEY116=(IToken)Match(input,ENDKEY,Follow._ENDKEY_in_let_expr2181); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_ENDKEY.Add(ENDKEY116);



			{
			// AST REWRITE
			// elements: expr_seq, decl
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 384:4: -> ^( LET ^( DECL_BLOCK ( decl )+ ) expr_seq )
			{
				DebugLocation(384, 7);
				// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:384:7: ^( LET ^( DECL_BLOCK ( decl )+ ) expr_seq )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(384, 9);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(LET, "LET"), root_1);

				DebugLocation(384, 13);
				// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:384:13: ^( DECL_BLOCK ( decl )+ )
				{
				object root_2 = (object)adaptor.Nil();
				DebugLocation(384, 15);
				root_2 = (object)adaptor.BecomeRoot((object)adaptor.Create(DECL_BLOCK, "DECL_BLOCK"), root_2);

				DebugLocation(384, 26);
				if (!(stream_decl.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_decl.HasNext )
				{
					DebugLocation(384, 26);
					adaptor.AddChild(root_2, stream_decl.NextTree());

				}
				stream_decl.Reset();

				adaptor.AddChild(root_1, root_2);
				}
				DebugLocation(384, 33);
				adaptor.AddChild(root_1, stream_expr_seq.NextTree());

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("let_expr", 28);
			LeaveRule("let_expr", 28);
			LeaveRule_let_expr();
		}
		DebugLocation(385, 1);
		} finally { DebugExitRule(GrammarFileName, "let_expr"); }
		return retval;

	}
	// $ANTLR end "let_expr"

	partial void EnterRule_lvalue();
	partial void LeaveRule_lvalue();

	// $ANTLR start "lvalue"
	// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:387:1: lvalue : type_id ( lvalue_access )? -> ^( VAR_ACCESS type_id ( lvalue_access )? ) ;
	[GrammarRule("lvalue")]
	private AstParserRuleReturnScope<object, IToken> lvalue()
	{
		EnterRule_lvalue();
		EnterRule("lvalue", 29);
		TraceIn("lvalue", 29);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> type_id117 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> lvalue_access118 = default(AstParserRuleReturnScope<object, IToken>);

		RewriteRuleSubtreeStream stream_type_id=new RewriteRuleSubtreeStream(adaptor,"rule type_id");
		RewriteRuleSubtreeStream stream_lvalue_access=new RewriteRuleSubtreeStream(adaptor,"rule lvalue_access");
		try { DebugEnterRule(GrammarFileName, "lvalue");
		DebugLocation(387, 1);
		try
		{
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:388:2: ( type_id ( lvalue_access )? -> ^( VAR_ACCESS type_id ( lvalue_access )? ) )
			DebugEnterAlt(1);
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:388:4: type_id ( lvalue_access )?
			{
			DebugLocation(388, 4);
			PushFollow(Follow._type_id_in_lvalue2211);
			type_id117=type_id();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_type_id.Add(type_id117.Tree);
			DebugLocation(388, 12);
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:388:12: ( lvalue_access )?
			int alt23=2;
			try { DebugEnterSubRule(23);
			try { DebugEnterDecision(23, false);
			int LA23_0 = input.LA(1);

			if ((LA23_0==DOT||LA23_0==LBRACKET))
			{
				alt23 = 1;
			}
			} finally { DebugExitDecision(23); }
			switch (alt23)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:388:12: lvalue_access
				{
				DebugLocation(388, 12);
				PushFollow(Follow._lvalue_access_in_lvalue2213);
				lvalue_access118=lvalue_access();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_lvalue_access.Add(lvalue_access118.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(23); }



			{
			// AST REWRITE
			// elements: lvalue_access, type_id
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 388:27: -> ^( VAR_ACCESS type_id ( lvalue_access )? )
			{
				DebugLocation(388, 30);
				// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:388:30: ^( VAR_ACCESS type_id ( lvalue_access )? )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(388, 32);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(VAR_ACCESS, "VAR_ACCESS"), root_1);

				DebugLocation(388, 43);
				adaptor.AddChild(root_1, stream_type_id.NextTree());
				DebugLocation(388, 51);
				// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:388:51: ( lvalue_access )?
				if (stream_lvalue_access.HasNext)
				{
					DebugLocation(388, 51);
					adaptor.AddChild(root_1, stream_lvalue_access.NextTree());

				}
				stream_lvalue_access.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("lvalue", 29);
			LeaveRule("lvalue", 29);
			LeaveRule_lvalue();
		}
		DebugLocation(389, 1);
		} finally { DebugExitRule(GrammarFileName, "lvalue"); }
		return retval;

	}
	// $ANTLR end "lvalue"

	partial void EnterRule_lvalue_access();
	partial void LeaveRule_lvalue_access();

	// $ANTLR start "lvalue_access"
	// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:391:1: lvalue_access : ( DOT type_id ( lvalue_access )? -> ^( FIELD_ACCESS type_id ( lvalue_access )? ) | LBRACKET disjunction_expr RBRACKET ( lvalue_access )? -> ^( ARRAY_ACCESS disjunction_expr ( lvalue_access )? ) );
	[GrammarRule("lvalue_access")]
	private AstParserRuleReturnScope<object, IToken> lvalue_access()
	{
		EnterRule_lvalue_access();
		EnterRule("lvalue_access", 30);
		TraceIn("lvalue_access", 30);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken DOT119 = default(IToken);
		IToken LBRACKET122 = default(IToken);
		IToken RBRACKET124 = default(IToken);
		AstParserRuleReturnScope<object, IToken> type_id120 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> lvalue_access121 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> disjunction_expr123 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> lvalue_access125 = default(AstParserRuleReturnScope<object, IToken>);

		object DOT119_tree = default(object);
		object LBRACKET122_tree = default(object);
		object RBRACKET124_tree = default(object);
		RewriteRuleITokenStream stream_DOT=new RewriteRuleITokenStream(adaptor,"token DOT");
		RewriteRuleITokenStream stream_LBRACKET=new RewriteRuleITokenStream(adaptor,"token LBRACKET");
		RewriteRuleITokenStream stream_RBRACKET=new RewriteRuleITokenStream(adaptor,"token RBRACKET");
		RewriteRuleSubtreeStream stream_type_id=new RewriteRuleSubtreeStream(adaptor,"rule type_id");
		RewriteRuleSubtreeStream stream_disjunction_expr=new RewriteRuleSubtreeStream(adaptor,"rule disjunction_expr");
		RewriteRuleSubtreeStream stream_lvalue_access=new RewriteRuleSubtreeStream(adaptor,"rule lvalue_access");
		try { DebugEnterRule(GrammarFileName, "lvalue_access");
		DebugLocation(391, 1);
		try
		{
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:392:2: ( DOT type_id ( lvalue_access )? -> ^( FIELD_ACCESS type_id ( lvalue_access )? ) | LBRACKET disjunction_expr RBRACKET ( lvalue_access )? -> ^( ARRAY_ACCESS disjunction_expr ( lvalue_access )? ) )
			int alt26=2;
			try { DebugEnterDecision(26, false);
			int LA26_0 = input.LA(1);

			if ((LA26_0==DOT))
			{
				alt26 = 1;
			}
			else if ((LA26_0==LBRACKET))
			{
				alt26 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 26, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(26); }
			switch (alt26)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:392:4: DOT type_id ( lvalue_access )?
				{
				DebugLocation(392, 4);
				DOT119=(IToken)Match(input,DOT,Follow._DOT_in_lvalue_access2236); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_DOT.Add(DOT119);

				DebugLocation(392, 8);
				PushFollow(Follow._type_id_in_lvalue_access2238);
				type_id120=type_id();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_type_id.Add(type_id120.Tree);
				DebugLocation(392, 16);
				// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:392:16: ( lvalue_access )?
				int alt24=2;
				try { DebugEnterSubRule(24);
				try { DebugEnterDecision(24, false);
				int LA24_0 = input.LA(1);

				if ((LA24_0==DOT||LA24_0==LBRACKET))
				{
					alt24 = 1;
				}
				} finally { DebugExitDecision(24); }
				switch (alt24)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:392:16: lvalue_access
					{
					DebugLocation(392, 16);
					PushFollow(Follow._lvalue_access_in_lvalue_access2240);
					lvalue_access121=lvalue_access();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_lvalue_access.Add(lvalue_access121.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(24); }



				{
				// AST REWRITE
				// elements: lvalue_access, type_id
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 393:13: -> ^( FIELD_ACCESS type_id ( lvalue_access )? )
				{
					DebugLocation(393, 16);
					// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:393:16: ^( FIELD_ACCESS type_id ( lvalue_access )? )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(393, 18);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(FIELD_ACCESS, "FIELD_ACCESS"), root_1);

					DebugLocation(393, 31);
					adaptor.AddChild(root_1, stream_type_id.NextTree());
					DebugLocation(393, 39);
					// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:393:39: ( lvalue_access )?
					if (stream_lvalue_access.HasNext)
					{
						DebugLocation(393, 39);
						adaptor.AddChild(root_1, stream_lvalue_access.NextTree());

					}
					stream_lvalue_access.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:394:4: LBRACKET disjunction_expr RBRACKET ( lvalue_access )?
				{
				DebugLocation(394, 4);
				LBRACKET122=(IToken)Match(input,LBRACKET,Follow._LBRACKET_in_lvalue_access2269); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_LBRACKET.Add(LBRACKET122);

				DebugLocation(394, 13);
				PushFollow(Follow._disjunction_expr_in_lvalue_access2271);
				disjunction_expr123=disjunction_expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_disjunction_expr.Add(disjunction_expr123.Tree);
				DebugLocation(394, 30);
				RBRACKET124=(IToken)Match(input,RBRACKET,Follow._RBRACKET_in_lvalue_access2273); if (state.failed) return retval; 
				if (state.backtracking == 0) stream_RBRACKET.Add(RBRACKET124);

				DebugLocation(394, 39);
				// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:394:39: ( lvalue_access )?
				int alt25=2;
				try { DebugEnterSubRule(25);
				try { DebugEnterDecision(25, false);
				int LA25_0 = input.LA(1);

				if ((LA25_0==DOT||LA25_0==LBRACKET))
				{
					alt25 = 1;
				}
				} finally { DebugExitDecision(25); }
				switch (alt25)
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:394:39: lvalue_access
					{
					DebugLocation(394, 39);
					PushFollow(Follow._lvalue_access_in_lvalue_access2275);
					lvalue_access125=lvalue_access();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_lvalue_access.Add(lvalue_access125.Tree);

					}
					break;

				}
				} finally { DebugExitSubRule(25); }



				{
				// AST REWRITE
				// elements: lvalue_access, disjunction_expr
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 395:4: -> ^( ARRAY_ACCESS disjunction_expr ( lvalue_access )? )
				{
					DebugLocation(395, 7);
					// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:395:7: ^( ARRAY_ACCESS disjunction_expr ( lvalue_access )? )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(395, 9);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ARRAY_ACCESS, "ARRAY_ACCESS"), root_1);

					DebugLocation(395, 22);
					adaptor.AddChild(root_1, stream_disjunction_expr.NextTree());
					DebugLocation(395, 39);
					// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:395:39: ( lvalue_access )?
					if (stream_lvalue_access.HasNext)
					{
						DebugLocation(395, 39);
						adaptor.AddChild(root_1, stream_lvalue_access.NextTree());

					}
					stream_lvalue_access.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("lvalue_access", 30);
			LeaveRule("lvalue_access", 30);
			LeaveRule_lvalue_access();
		}
		DebugLocation(396, 1);
		} finally { DebugExitRule(GrammarFileName, "lvalue_access"); }
		return retval;

	}
	// $ANTLR end "lvalue_access"

	partial void EnterRule_funcall();
	partial void LeaveRule_funcall();

	// $ANTLR start "funcall"
	// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:398:1: funcall : type_id LPAREN ( arg_list )? RPAREN -> ^( FUN_CALL type_id ( arg_list )? ) ;
	[GrammarRule("funcall")]
	private AstParserRuleReturnScope<object, IToken> funcall()
	{
		EnterRule_funcall();
		EnterRule("funcall", 31);
		TraceIn("funcall", 31);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken LPAREN127 = default(IToken);
		IToken RPAREN129 = default(IToken);
		AstParserRuleReturnScope<object, IToken> type_id126 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> arg_list128 = default(AstParserRuleReturnScope<object, IToken>);

		object LPAREN127_tree = default(object);
		object RPAREN129_tree = default(object);
		RewriteRuleITokenStream stream_LPAREN=new RewriteRuleITokenStream(adaptor,"token LPAREN");
		RewriteRuleITokenStream stream_RPAREN=new RewriteRuleITokenStream(adaptor,"token RPAREN");
		RewriteRuleSubtreeStream stream_type_id=new RewriteRuleSubtreeStream(adaptor,"rule type_id");
		RewriteRuleSubtreeStream stream_arg_list=new RewriteRuleSubtreeStream(adaptor,"rule arg_list");
		try { DebugEnterRule(GrammarFileName, "funcall");
		DebugLocation(398, 1);
		try
		{
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:399:2: ( type_id LPAREN ( arg_list )? RPAREN -> ^( FUN_CALL type_id ( arg_list )? ) )
			DebugEnterAlt(1);
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:399:4: type_id LPAREN ( arg_list )? RPAREN
			{
			DebugLocation(399, 4);
			PushFollow(Follow._type_id_in_funcall2301);
			type_id126=type_id();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_type_id.Add(type_id126.Tree);
			DebugLocation(399, 12);
			LPAREN127=(IToken)Match(input,LPAREN,Follow._LPAREN_in_funcall2303); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_LPAREN.Add(LPAREN127);

			DebugLocation(399, 19);
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:399:19: ( arg_list )?
			int alt27=2;
			try { DebugEnterSubRule(27);
			try { DebugEnterDecision(27, false);
			int LA27_0 = input.LA(1);

			if ((LA27_0==BREAKKEY||LA27_0==FORKEY||LA27_0==ID||LA27_0==IFKEY||(LA27_0>=INT && LA27_0<=INTKEY)||LA27_0==LETKEY||LA27_0==LPAREN||LA27_0==MINUS||LA27_0==NILKEY||(LA27_0>=STRING && LA27_0<=STRINGKEY)||LA27_0==WHILEKEY))
			{
				alt27 = 1;
			}
			} finally { DebugExitDecision(27); }
			switch (alt27)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:399:19: arg_list
				{
				DebugLocation(399, 19);
				PushFollow(Follow._arg_list_in_funcall2305);
				arg_list128=arg_list();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_arg_list.Add(arg_list128.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(27); }

			DebugLocation(399, 29);
			RPAREN129=(IToken)Match(input,RPAREN,Follow._RPAREN_in_funcall2308); if (state.failed) return retval; 
			if (state.backtracking == 0) stream_RPAREN.Add(RPAREN129);



			{
			// AST REWRITE
			// elements: arg_list, type_id
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 400:4: -> ^( FUN_CALL type_id ( arg_list )? )
			{
				DebugLocation(400, 7);
				// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:400:7: ^( FUN_CALL type_id ( arg_list )? )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(400, 9);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(FUN_CALL, "FUN_CALL"), root_1);

				DebugLocation(400, 18);
				adaptor.AddChild(root_1, stream_type_id.NextTree());
				DebugLocation(400, 26);
				// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:400:26: ( arg_list )?
				if (stream_arg_list.HasNext)
				{
					DebugLocation(400, 26);
					adaptor.AddChild(root_1, stream_arg_list.NextTree());

				}
				stream_arg_list.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("funcall", 31);
			LeaveRule("funcall", 31);
			LeaveRule_funcall();
		}
		DebugLocation(401, 1);
		} finally { DebugExitRule(GrammarFileName, "funcall"); }
		return retval;

	}
	// $ANTLR end "funcall"

	partial void EnterRule_expr_seq();
	partial void LeaveRule_expr_seq();

	// $ANTLR start "expr_seq"
	// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:403:1: expr_seq : ( expr ( SEMI expr )* -> ^( EXPR_SEQ ( expr )+ ) | -> ^( EXPR_SEQ ) );
	[GrammarRule("expr_seq")]
	private AstParserRuleReturnScope<object, IToken> expr_seq()
	{
		EnterRule_expr_seq();
		EnterRule("expr_seq", 32);
		TraceIn("expr_seq", 32);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken SEMI131 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expr130 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expr132 = default(AstParserRuleReturnScope<object, IToken>);

		object SEMI131_tree = default(object);
		RewriteRuleITokenStream stream_SEMI=new RewriteRuleITokenStream(adaptor,"token SEMI");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		try { DebugEnterRule(GrammarFileName, "expr_seq");
		DebugLocation(403, 1);
		try
		{
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:404:2: ( expr ( SEMI expr )* -> ^( EXPR_SEQ ( expr )+ ) | -> ^( EXPR_SEQ ) )
			int alt29=2;
			try { DebugEnterDecision(29, false);
			int LA29_0 = input.LA(1);

			if ((LA29_0==BREAKKEY||LA29_0==FORKEY||LA29_0==ID||LA29_0==IFKEY||(LA29_0>=INT && LA29_0<=INTKEY)||LA29_0==LETKEY||LA29_0==LPAREN||LA29_0==MINUS||LA29_0==NILKEY||(LA29_0>=STRING && LA29_0<=STRINGKEY)||LA29_0==WHILEKEY))
			{
				alt29 = 1;
			}
			else if ((LA29_0==ENDKEY||LA29_0==RPAREN))
			{
				alt29 = 2;
			}
			else
			{
				if (state.backtracking>0) {state.failed=true; return retval;}
				NoViableAltException nvae = new NoViableAltException("", 29, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(29); }
			switch (alt29)
			{
			case 1:
				DebugEnterAlt(1);
				// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:404:4: expr ( SEMI expr )*
				{
				DebugLocation(404, 4);
				PushFollow(Follow._expr_in_expr_seq2334);
				expr130=expr();
				PopFollow();
				if (state.failed) return retval;
				if (state.backtracking == 0) stream_expr.Add(expr130.Tree);
				DebugLocation(404, 9);
				// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:404:9: ( SEMI expr )*
				try { DebugEnterSubRule(28);
				while (true)
				{
					int alt28=2;
					try { DebugEnterDecision(28, false);
					int LA28_0 = input.LA(1);

					if ((LA28_0==SEMI))
					{
						alt28 = 1;
					}


					} finally { DebugExitDecision(28); }
					switch ( alt28 )
					{
					case 1:
						DebugEnterAlt(1);
						// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:404:10: SEMI expr
						{
						DebugLocation(404, 10);
						SEMI131=(IToken)Match(input,SEMI,Follow._SEMI_in_expr_seq2337); if (state.failed) return retval; 
						if (state.backtracking == 0) stream_SEMI.Add(SEMI131);

						DebugLocation(404, 15);
						PushFollow(Follow._expr_in_expr_seq2339);
						expr132=expr();
						PopFollow();
						if (state.failed) return retval;
						if (state.backtracking == 0) stream_expr.Add(expr132.Tree);

						}
						break;

					default:
						goto loop28;
					}
				}

				loop28:
					;

				} finally { DebugExitSubRule(28); }



				{
				// AST REWRITE
				// elements: expr
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 405:4: -> ^( EXPR_SEQ ( expr )+ )
				{
					DebugLocation(405, 7);
					// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:405:7: ^( EXPR_SEQ ( expr )+ )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(405, 9);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(EXPR_SEQ, "EXPR_SEQ"), root_1);

					DebugLocation(405, 18);
					if (!(stream_expr.HasNext))
					{
						throw new RewriteEarlyExitException();
					}
					while ( stream_expr.HasNext )
					{
						DebugLocation(405, 18);
						adaptor.AddChild(root_1, stream_expr.NextTree());

					}
					stream_expr.Reset();

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:406:9: 
				{

				{
				// AST REWRITE
				// elements: 
				// token labels: 
				// rule labels: retval
				// token list labels: 
				// rule list labels: 
				// wildcard labels: 
				if (state.backtracking == 0) {
				retval.Tree = root_0;
				RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

				root_0 = (object)adaptor.Nil();
				// 406:9: -> ^( EXPR_SEQ )
				{
					DebugLocation(406, 12);
					// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:406:12: ^( EXPR_SEQ )
					{
					object root_1 = (object)adaptor.Nil();
					DebugLocation(406, 14);
					root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(EXPR_SEQ, "EXPR_SEQ"), root_1);

					adaptor.AddChild(root_0, root_1);
					}

				}

				retval.Tree = root_0;
				}
				}

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expr_seq", 32);
			LeaveRule("expr_seq", 32);
			LeaveRule_expr_seq();
		}
		DebugLocation(407, 1);
		} finally { DebugExitRule(GrammarFileName, "expr_seq"); }
		return retval;

	}
	// $ANTLR end "expr_seq"

	partial void EnterRule_arg_list();
	partial void LeaveRule_arg_list();

	// $ANTLR start "arg_list"
	// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:409:1: arg_list : expr ( COMMA expr )* -> ^( ARGS_FIELDS ( expr )+ ) ;
	[GrammarRule("arg_list")]
	private AstParserRuleReturnScope<object, IToken> arg_list()
	{
		EnterRule_arg_list();
		EnterRule("arg_list", 33);
		TraceIn("arg_list", 33);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken COMMA134 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expr133 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expr135 = default(AstParserRuleReturnScope<object, IToken>);

		object COMMA134_tree = default(object);
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_expr=new RewriteRuleSubtreeStream(adaptor,"rule expr");
		try { DebugEnterRule(GrammarFileName, "arg_list");
		DebugLocation(409, 1);
		try
		{
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:410:2: ( expr ( COMMA expr )* -> ^( ARGS_FIELDS ( expr )+ ) )
			DebugEnterAlt(1);
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:410:4: expr ( COMMA expr )*
			{
			DebugLocation(410, 4);
			PushFollow(Follow._expr_in_arg_list2381);
			expr133=expr();
			PopFollow();
			if (state.failed) return retval;
			if (state.backtracking == 0) stream_expr.Add(expr133.Tree);
			DebugLocation(410, 9);
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:410:9: ( COMMA expr )*
			try { DebugEnterSubRule(30);
			while (true)
			{
				int alt30=2;
				try { DebugEnterDecision(30, false);
				int LA30_0 = input.LA(1);

				if ((LA30_0==COMMA))
				{
					alt30 = 1;
				}


				} finally { DebugExitDecision(30); }
				switch ( alt30 )
				{
				case 1:
					DebugEnterAlt(1);
					// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:410:10: COMMA expr
					{
					DebugLocation(410, 10);
					COMMA134=(IToken)Match(input,COMMA,Follow._COMMA_in_arg_list2384); if (state.failed) return retval; 
					if (state.backtracking == 0) stream_COMMA.Add(COMMA134);

					DebugLocation(410, 16);
					PushFollow(Follow._expr_in_arg_list2386);
					expr135=expr();
					PopFollow();
					if (state.failed) return retval;
					if (state.backtracking == 0) stream_expr.Add(expr135.Tree);

					}
					break;

				default:
					goto loop30;
				}
			}

			loop30:
				;

			} finally { DebugExitSubRule(30); }



			{
			// AST REWRITE
			// elements: expr
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			if (state.backtracking == 0) {
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 411:4: -> ^( ARGS_FIELDS ( expr )+ )
			{
				DebugLocation(411, 7);
				// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:411:7: ^( ARGS_FIELDS ( expr )+ )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(411, 9);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(ARGS_FIELDS, "ARGS_FIELDS"), root_1);

				DebugLocation(411, 21);
				if (!(stream_expr.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_expr.HasNext )
				{
					DebugLocation(411, 21);
					adaptor.AddChild(root_1, stream_expr.NextTree());

				}
				stream_expr.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			if (state.backtracking == 0) {
			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);
			}
		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("arg_list", 33);
			LeaveRule("arg_list", 33);
			LeaveRule_arg_list();
		}
		DebugLocation(412, 1);
		} finally { DebugExitRule(GrammarFileName, "arg_list"); }
		return retval;

	}
	// $ANTLR end "arg_list"

	partial void EnterRule_synpred1_tiger_fragment();
	partial void LeaveRule_synpred1_tiger_fragment();

	// $ANTLR start synpred1_tiger
	public void synpred1_tiger_fragment()
	{
		EnterRule_synpred1_tiger_fragment();
		EnterRule("synpred1_tiger_fragment", 34);
		TraceIn("synpred1_tiger_fragment", 34);
		try
		{
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:223:4: ( ID LBRACKET disjunction_expr RBRACKET OFKEY )
			DebugEnterAlt(1);
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:223:5: ID LBRACKET disjunction_expr RBRACKET OFKEY
			{
			DebugLocation(223, 5);
			Match(input,ID,Follow._ID_in_synpred1_tiger1172); if (state.failed) return;
			DebugLocation(223, 8);
			Match(input,LBRACKET,Follow._LBRACKET_in_synpred1_tiger1174); if (state.failed) return;
			DebugLocation(223, 17);
			PushFollow(Follow._disjunction_expr_in_synpred1_tiger1176);
			disjunction_expr();
			PopFollow();
			if (state.failed) return;
			DebugLocation(223, 34);
			Match(input,RBRACKET,Follow._RBRACKET_in_synpred1_tiger1178); if (state.failed) return;
			DebugLocation(223, 43);
			Match(input,OFKEY,Follow._OFKEY_in_synpred1_tiger1180); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred1_tiger_fragment", 34);
			LeaveRule("synpred1_tiger_fragment", 34);
			LeaveRule_synpred1_tiger_fragment();
		}
	}
	// $ANTLR end synpred1_tiger

	partial void EnterRule_synpred2_tiger_fragment();
	partial void LeaveRule_synpred2_tiger_fragment();

	// $ANTLR start synpred2_tiger
	public void synpred2_tiger_fragment()
	{
		EnterRule_synpred2_tiger_fragment();
		EnterRule("synpred2_tiger_fragment", 35);
		TraceIn("synpred2_tiger_fragment", 35);
		try
		{
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:224:4: ( lvalue ASSIGN )
			DebugEnterAlt(1);
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:224:5: lvalue ASSIGN
			{
			DebugLocation(224, 5);
			PushFollow(Follow._lvalue_in_synpred2_tiger1191);
			lvalue();
			PopFollow();
			if (state.failed) return;
			DebugLocation(224, 12);
			Match(input,ASSIGN,Follow._ASSIGN_in_synpred2_tiger1193); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred2_tiger_fragment", 35);
			LeaveRule("synpred2_tiger_fragment", 35);
			LeaveRule_synpred2_tiger_fragment();
		}
	}
	// $ANTLR end synpred2_tiger

	partial void EnterRule_synpred3_tiger_fragment();
	partial void LeaveRule_synpred3_tiger_fragment();

	// $ANTLR start synpred3_tiger
	public void synpred3_tiger_fragment()
	{
		EnterRule_synpred3_tiger_fragment();
		EnterRule("synpred3_tiger_fragment", 36);
		TraceIn("synpred3_tiger_fragment", 36);
		try
		{
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:238:6: ( ID LBRACKET disjunction_expr RBRACKET OFKEY )
			DebugEnterAlt(1);
			// D:\\~Compilador\\!yatc\\Grammar\\tiger.g:238:7: ID LBRACKET disjunction_expr RBRACKET OFKEY
			{
			DebugLocation(238, 7);
			Match(input,ID,Follow._ID_in_synpred3_tiger1279); if (state.failed) return;
			DebugLocation(238, 10);
			Match(input,LBRACKET,Follow._LBRACKET_in_synpred3_tiger1281); if (state.failed) return;
			DebugLocation(238, 19);
			PushFollow(Follow._disjunction_expr_in_synpred3_tiger1283);
			disjunction_expr();
			PopFollow();
			if (state.failed) return;
			DebugLocation(238, 36);
			Match(input,RBRACKET,Follow._RBRACKET_in_synpred3_tiger1285); if (state.failed) return;
			DebugLocation(238, 45);
			Match(input,OFKEY,Follow._OFKEY_in_synpred3_tiger1287); if (state.failed) return;

			}

		}
		finally
		{
			TraceOut("synpred3_tiger_fragment", 36);
			LeaveRule("synpred3_tiger_fragment", 36);
			LeaveRule_synpred3_tiger_fragment();
		}
	}
	// $ANTLR end synpred3_tiger
	#endregion Rules

	#region Synpreds
	private bool EvaluatePredicate(System.Action fragment)
	{
		bool success = false;
		state.backtracking++;
		try { DebugBeginBacktrack(state.backtracking);
		int start = input.Mark();
		try
		{
			fragment();
		}
		catch ( RecognitionException re )
		{
			System.Console.Error.WriteLine("impossible: "+re);
		}
		success = !state.failed;
		input.Rewind(start);
		} finally { DebugEndBacktrack(state.backtracking, success); }
		state.backtracking--;
		state.failed=false;
		return success;
	}
	#endregion Synpreds


	#region DFA
	private DFA2 dfa2;

	protected override void InitDFAs()
	{
		base.InitDFAs();
		dfa2 = new DFA2( this, SpecialStateTransition2 );
	}

	private class DFA2 : DFA
	{
		private const string DFA2_eotS =
			"\x4D\xFFFF";
		private const string DFA2_eofS =
			"\x1\xFFFF\x2\x3\x4A\xFFFF";
		private const string DFA2_minS =
			"\x1\xF\x2\x5\x8\xFFFF\x1\x24\x1\xFFFF\x1\x2C\x16\xFFFF\x1\x2C\x1\x24"+
			"\x16\xFFFF\x10\x0\x1\xFFFF";
		private const string DFA2_maxS =
			"\x1\x5A\x2\x56\x8\xFFFF\x1\x4E\x1\xFFFF\x1\x4E\x16\xFFFF\x2\x4E\x16\xFFFF"+
			"\x10\x0\x1\xFFFF";
		private const string DFA2_acceptS =
			"\x3\xFFFF\x1\x3\x5\xFFFF\x1\x5\x1\x6\x1\xFFFF\x1\x4\x1\xFFFF\x1\x2\x17"+
			"\xFFFF\x1\x2\x25\xFFFF\x1\x1";
		private const string DFA2_specialS =
			"\x1\xFFFF\x1\x0\x1\x1\x39\xFFFF\x1\x2\x1\x3\x1\x4\x1\x5\x1\x6\x1\x7\x1"+
			"\x8\x1\x9\x1\xA\x1\xB\x1\xC\x1\xD\x1\xE\x1\xF\x1\x10\x1\x11\x1\xFFFF}>";
		private static readonly string[] DFA2_transitionS =
			{
				"\x1\xA\x14\xFFFF\x1\x3\x7\xFFFF\x1\x1\x1\xFFFF\x1\x3\x1\xFFFF\x1\x3"+
				"\x1\x2\x2\xFFFF\x1\x3\x2\xFFFF\x1\x3\x2\xFFFF\x1\x3\x3\xFFFF\x1\x3\xE"+
				"\xFFFF\x1\x3\x1\x2\xB\xFFFF\x1\x9",
				"\x1\x3\x6\xFFFF\x1\xE\x4\xFFFF\x1\x3\x3\xFFFF\x2\x3\x1\xD\x2\x3\x1"+
				"\xFFFF\x1\x3\x9\xFFFF\x1\x3\x4\xFFFF\x2\x3\x3\xFFFF\x1\x3\x2\xFFFF\x1"+
				"\xB\x3\xFFFF\x1\xC\x5\x3\x3\xFFFF\x1\x3\x1\xFFFF\x1\x3\x1\xFFFF\x1\x3"+
				"\x3\xFFFF\x1\x3\x2\xFFFF\x3\x3\x2\xFFFF\x2\x3\x1\xFFFF\x1\x3\x3\xFFFF"+
				"\x1\x3",
				"\x1\x3\x6\xFFFF\x1\x26\x4\xFFFF\x1\x3\x3\xFFFF\x2\x3\x1\x24\x2\x3\x1"+
				"\xFFFF\x1\x3\x9\xFFFF\x1\x3\x4\xFFFF\x2\x3\x3\xFFFF\x1\x3\x2\xFFFF\x1"+
				"\x25\x4\xFFFF\x5\x3\x3\xFFFF\x1\x3\x1\xFFFF\x1\x3\x1\xFFFF\x1\x3\x3"+
				"\xFFFF\x1\x3\x2\xFFFF\x3\x3\x2\xFFFF\x2\x3\x1\xFFFF\x1\x3\x3\xFFFF\x1"+
				"\x3",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x1\x40\x7\xFFFF\x1\x3E\x1\xFFFF\x1\x3F\x1\xFFFF\x1\x3D\x1\x3E\x2\xFFFF"+
				"\x1\x41\x2\xFFFF\x1\x42\x2\xFFFF\x1\x3C\x3\xFFFF\x1\x3D\xE\xFFFF\x1"+
				"\x3D\x1\x3E",
				"",
				"\x1\x43\x4\xFFFF\x1\x43\x1C\xFFFF\x1\x43",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x1\x44\x4\xFFFF\x1\x44\x1C\xFFFF\x1\x44",
				"\x1\x49\x7\xFFFF\x1\x47\x1\xFFFF\x1\x48\x1\xFFFF\x1\x46\x1\x47\x2\xFFFF"+
				"\x1\x4A\x2\xFFFF\x1\x4B\x2\xFFFF\x1\x45\x3\xFFFF\x1\x46\xE\xFFFF\x1"+
				"\x46\x1\x47",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				"\x1\xFFFF",
				""
			};

		private static readonly short[] DFA2_eot = DFA.UnpackEncodedString(DFA2_eotS);
		private static readonly short[] DFA2_eof = DFA.UnpackEncodedString(DFA2_eofS);
		private static readonly char[] DFA2_min = DFA.UnpackEncodedStringToUnsignedChars(DFA2_minS);
		private static readonly char[] DFA2_max = DFA.UnpackEncodedStringToUnsignedChars(DFA2_maxS);
		private static readonly short[] DFA2_accept = DFA.UnpackEncodedString(DFA2_acceptS);
		private static readonly short[] DFA2_special = DFA.UnpackEncodedString(DFA2_specialS);
		private static readonly short[][] DFA2_transition;

		static DFA2()
		{
			int numStates = DFA2_transitionS.Length;
			DFA2_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA2_transition[i] = DFA.UnpackEncodedString(DFA2_transitionS[i]);
			}
		}

		public DFA2( BaseRecognizer recognizer, SpecialStateTransitionHandler specialStateTransition )
			: base(specialStateTransition)
		{
			this.recognizer = recognizer;
			this.decisionNumber = 2;
			this.eot = DFA2_eot;
			this.eof = DFA2_eof;
			this.min = DFA2_min;
			this.max = DFA2_max;
			this.accept = DFA2_accept;
			this.special = DFA2_special;
			this.transition = DFA2_transition;
		}

		public override string Description { get { return "222:1: expr : ( ( ID LBRACKET disjunction_expr RBRACKET OFKEY )=> array_inst | ( lvalue ASSIGN )=> assignment | disjunction_expr | record_inst | while_stat | BREAKKEY -> BREAK );"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}

	private int SpecialStateTransition2(DFA dfa, int s, IIntStream _input)
	{
		ITokenStream input = (ITokenStream)_input;
		int _s = s;
		switch (s)
		{
			case 0:
				int LA2_1 = input.LA(1);


				int index2_1 = input.Index;
				input.Rewind();
				s = -1;
				if ((LA2_1==LBRACKET)) {s = 11;}

				else if ((LA2_1==LKEY)) {s = 12;}

				else if ((LA2_1==DOT)) {s = 13;}

				else if ((LA2_1==ASSIGN) && (EvaluatePredicate(synpred2_tiger_fragment))) {s = 14;}

				else if ((LA2_1==EOF||LA2_1==AND||LA2_1==COMMA||(LA2_1>=DIV && LA2_1<=DOKEY)||(LA2_1>=ELSEKEY && LA2_1<=ENDKEY)||LA2_1==EQ||LA2_1==FUNCTIONKEY||(LA2_1>=GT && LA2_1<=GTEQ)||LA2_1==INKEY||(LA2_1>=LPAREN && LA2_1<=MULT)||LA2_1==NOTEQ||LA2_1==OR||LA2_1==PLUS||LA2_1==RBRACKET||(LA2_1>=RKEY && LA2_1<=SEMI)||(LA2_1>=THENKEY && LA2_1<=TOKEY)||LA2_1==TYPEKEY||LA2_1==VARKEY)) {s = 3;}


				input.Seek(index2_1);
				if (s >= 0) return s;
				break;

			case 1:
				int LA2_2 = input.LA(1);


				int index2_2 = input.Index;
				input.Rewind();
				s = -1;
				if ((LA2_2==DOT)) {s = 36;}

				else if ((LA2_2==LBRACKET)) {s = 37;}

				else if ((LA2_2==ASSIGN) && (EvaluatePredicate(synpred2_tiger_fragment))) {s = 38;}

				else if ((LA2_2==EOF||LA2_2==AND||LA2_2==COMMA||(LA2_2>=DIV && LA2_2<=DOKEY)||(LA2_2>=ELSEKEY && LA2_2<=ENDKEY)||LA2_2==EQ||LA2_2==FUNCTIONKEY||(LA2_2>=GT && LA2_2<=GTEQ)||LA2_2==INKEY||(LA2_2>=LPAREN && LA2_2<=MULT)||LA2_2==NOTEQ||LA2_2==OR||LA2_2==PLUS||LA2_2==RBRACKET||(LA2_2>=RKEY && LA2_2<=SEMI)||(LA2_2>=THENKEY && LA2_2<=TOKEY)||LA2_2==TYPEKEY||LA2_2==VARKEY)) {s = 3;}


				input.Seek(index2_2);
				if (s >= 0) return s;
				break;

			case 2:
				int LA2_60 = input.LA(1);


				int index2_60 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred1_tiger_fragment))) {s = 76;}

				else if ((EvaluatePredicate(synpred2_tiger_fragment))) {s = 38;}

				else if ((true)) {s = 3;}


				input.Seek(index2_60);
				if (s >= 0) return s;
				break;

			case 3:
				int LA2_61 = input.LA(1);


				int index2_61 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred1_tiger_fragment))) {s = 76;}

				else if ((EvaluatePredicate(synpred2_tiger_fragment))) {s = 38;}

				else if ((true)) {s = 3;}


				input.Seek(index2_61);
				if (s >= 0) return s;
				break;

			case 4:
				int LA2_62 = input.LA(1);


				int index2_62 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred1_tiger_fragment))) {s = 76;}

				else if ((EvaluatePredicate(synpred2_tiger_fragment))) {s = 38;}

				else if ((true)) {s = 3;}


				input.Seek(index2_62);
				if (s >= 0) return s;
				break;

			case 5:
				int LA2_63 = input.LA(1);


				int index2_63 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred1_tiger_fragment))) {s = 76;}

				else if ((EvaluatePredicate(synpred2_tiger_fragment))) {s = 38;}

				else if ((true)) {s = 3;}


				input.Seek(index2_63);
				if (s >= 0) return s;
				break;

			case 6:
				int LA2_64 = input.LA(1);


				int index2_64 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred1_tiger_fragment))) {s = 76;}

				else if ((EvaluatePredicate(synpred2_tiger_fragment))) {s = 38;}

				else if ((true)) {s = 3;}


				input.Seek(index2_64);
				if (s >= 0) return s;
				break;

			case 7:
				int LA2_65 = input.LA(1);


				int index2_65 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred1_tiger_fragment))) {s = 76;}

				else if ((EvaluatePredicate(synpred2_tiger_fragment))) {s = 38;}

				else if ((true)) {s = 3;}


				input.Seek(index2_65);
				if (s >= 0) return s;
				break;

			case 8:
				int LA2_66 = input.LA(1);


				int index2_66 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred1_tiger_fragment))) {s = 76;}

				else if ((EvaluatePredicate(synpred2_tiger_fragment))) {s = 38;}

				else if ((true)) {s = 3;}


				input.Seek(index2_66);
				if (s >= 0) return s;
				break;

			case 9:
				int LA2_67 = input.LA(1);


				int index2_67 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred2_tiger_fragment))) {s = 38;}

				else if ((true)) {s = 3;}


				input.Seek(index2_67);
				if (s >= 0) return s;
				break;

			case 10:
				int LA2_68 = input.LA(1);


				int index2_68 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred2_tiger_fragment))) {s = 38;}

				else if ((true)) {s = 3;}


				input.Seek(index2_68);
				if (s >= 0) return s;
				break;

			case 11:
				int LA2_69 = input.LA(1);


				int index2_69 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred2_tiger_fragment))) {s = 38;}

				else if ((true)) {s = 3;}


				input.Seek(index2_69);
				if (s >= 0) return s;
				break;

			case 12:
				int LA2_70 = input.LA(1);


				int index2_70 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred2_tiger_fragment))) {s = 38;}

				else if ((true)) {s = 3;}


				input.Seek(index2_70);
				if (s >= 0) return s;
				break;

			case 13:
				int LA2_71 = input.LA(1);


				int index2_71 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred2_tiger_fragment))) {s = 38;}

				else if ((true)) {s = 3;}


				input.Seek(index2_71);
				if (s >= 0) return s;
				break;

			case 14:
				int LA2_72 = input.LA(1);


				int index2_72 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred2_tiger_fragment))) {s = 38;}

				else if ((true)) {s = 3;}


				input.Seek(index2_72);
				if (s >= 0) return s;
				break;

			case 15:
				int LA2_73 = input.LA(1);


				int index2_73 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred2_tiger_fragment))) {s = 38;}

				else if ((true)) {s = 3;}


				input.Seek(index2_73);
				if (s >= 0) return s;
				break;

			case 16:
				int LA2_74 = input.LA(1);


				int index2_74 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred2_tiger_fragment))) {s = 38;}

				else if ((true)) {s = 3;}


				input.Seek(index2_74);
				if (s >= 0) return s;
				break;

			case 17:
				int LA2_75 = input.LA(1);


				int index2_75 = input.Index;
				input.Rewind();
				s = -1;
				if ((EvaluatePredicate(synpred2_tiger_fragment))) {s = 38;}

				else if ((true)) {s = 3;}


				input.Seek(index2_75);
				if (s >= 0) return s;
				break;
		}
		if (state.backtracking > 0) {state.failed=true; return -1;}
		NoViableAltException nvae = new NoViableAltException(dfa.Description, 2, _s, input);
		dfa.Error(nvae);
		throw nvae;
	}

	#endregion DFA

	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _expr_in_a_program1145 = new BitSet(new ulong[]{0x0UL});
		public static readonly BitSet _EOF_in_a_program1149 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _array_inst_in_expr1185 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _assignment_in_expr1198 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _disjunction_expr_in_expr1203 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _record_inst_in_expr1209 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _while_stat_in_expr1214 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _BREAKKEY_in_expr1219 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _conjunction_expr_in_disjunction_expr1248 = new BitSet(new ulong[]{0x2UL,0x2UL});
		public static readonly BitSet _OR_in_disjunction_expr1251 = new BitSet(new ulong[]{0x4493501000000000UL,0x6000UL});
		public static readonly BitSet _conjunction_expr_in_disjunction_expr1254 = new BitSet(new ulong[]{0x2UL,0x2UL});
		public static readonly BitSet _lvalue_in_assignment1267 = new BitSet(new ulong[]{0x1000UL});
		public static readonly BitSet _ASSIGN_in_assignment1269 = new BitSet(new ulong[]{0x4493501000000000UL,0x6000UL});
		public static readonly BitSet _array_inst_in_assignment1292 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _disjunction_expr_in_assignment1300 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _record_inst_in_assignment1308 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_record_inst1325 = new BitSet(new ulong[]{0x40000000000000UL});
		public static readonly BitSet _LKEY_in_record_inst1327 = new BitSet(new ulong[]{0x100000000000UL,0x400UL});
		public static readonly BitSet _field_inst_list_in_record_inst1329 = new BitSet(new ulong[]{0x0UL,0x400UL});
		public static readonly BitSet _RKEY_in_record_inst1332 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FORKEY_in_for_expr1359 = new BitSet(new ulong[]{0x2100000000000UL,0x4000UL});
		public static readonly BitSet _type_id_in_for_expr1361 = new BitSet(new ulong[]{0x1000UL});
		public static readonly BitSet _ASSIGN_in_for_expr1363 = new BitSet(new ulong[]{0x4493501000000000UL,0x6000UL});
		public static readonly BitSet _disjunction_expr_in_for_expr1365 = new BitSet(new ulong[]{0x0UL,0x10000UL});
		public static readonly BitSet _TOKEY_in_for_expr1367 = new BitSet(new ulong[]{0x4493501000000000UL,0x6000UL});
		public static readonly BitSet _disjunction_expr_in_for_expr1369 = new BitSet(new ulong[]{0x400000UL});
		public static readonly BitSet _DOKEY_in_for_expr1371 = new BitSet(new ulong[]{0x4493501000008000UL,0x4006000UL});
		public static readonly BitSet _expr_in_for_expr1373 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_array_inst1401 = new BitSet(new ulong[]{0x4000000000000UL});
		public static readonly BitSet _LBRACKET_in_array_inst1403 = new BitSet(new ulong[]{0x4493501000000000UL,0x6000UL});
		public static readonly BitSet _disjunction_expr_in_array_inst1405 = new BitSet(new ulong[]{0x0UL,0x80UL});
		public static readonly BitSet _RBRACKET_in_array_inst1407 = new BitSet(new ulong[]{0x0UL,0x1UL});
		public static readonly BitSet _OFKEY_in_array_inst1409 = new BitSet(new ulong[]{0x4493501000008000UL,0x4006000UL});
		public static readonly BitSet _expr_in_array_inst1411 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _relational_expr_in_conjunction_expr1437 = new BitSet(new ulong[]{0x22UL});
		public static readonly BitSet _AND_in_conjunction_expr1440 = new BitSet(new ulong[]{0x4493501000000000UL,0x6000UL});
		public static readonly BitSet _relational_expr_in_conjunction_expr1443 = new BitSet(new ulong[]{0x22UL});
		public static readonly BitSet _arith_expr_in_relational_expr1459 = new BitSet(new ulong[]{0x83000C0008000002UL});
		public static readonly BitSet _set_in_relational_expr1462 = new BitSet(new ulong[]{0x4493501000000000UL,0x6000UL});
		public static readonly BitSet _arith_expr_in_relational_expr1488 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _term_expr_in_arith_expr1502 = new BitSet(new ulong[]{0x400000000000002UL,0x8UL});
		public static readonly BitSet _set_in_arith_expr1505 = new BitSet(new ulong[]{0x4493501000000000UL,0x6000UL});
		public static readonly BitSet _term_expr_in_arith_expr1514 = new BitSet(new ulong[]{0x400000000000002UL,0x8UL});
		public static readonly BitSet _atom_in_term_expr1527 = new BitSet(new ulong[]{0x800000000200002UL});
		public static readonly BitSet _set_in_term_expr1530 = new BitSet(new ulong[]{0x4493501000000000UL,0x6000UL});
		public static readonly BitSet _atom_in_term_expr1539 = new BitSet(new ulong[]{0x800000000200002UL});
		public static readonly BitSet _record_field_inst_in_field_inst_list1553 = new BitSet(new ulong[]{0x20002UL});
		public static readonly BitSet _COMMA_in_field_inst_list1557 = new BitSet(new ulong[]{0x100000000000UL});
		public static readonly BitSet _record_field_inst_in_field_inst_list1559 = new BitSet(new ulong[]{0x20002UL});
		public static readonly BitSet _ID_in_record_field_inst1586 = new BitSet(new ulong[]{0x8000000UL});
		public static readonly BitSet _EQ_in_record_field_inst1588 = new BitSet(new ulong[]{0x4493501000008000UL,0x4006000UL});
		public static readonly BitSet _expr_in_record_field_inst1590 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _type_decl_in_decl1615 = new BitSet(new ulong[]{0x2UL,0x40000UL});
		public static readonly BitSet _var_decl_in_decl1633 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _fun_decl_in_decl1638 = new BitSet(new ulong[]{0x2000000002UL});
		public static readonly BitSet _TYPEKEY_in_type_decl1662 = new BitSet(new ulong[]{0x100000000000UL});
		public static readonly BitSet _ID_in_type_decl1664 = new BitSet(new ulong[]{0x8000000UL});
		public static readonly BitSet _EQ_in_type_decl1666 = new BitSet(new ulong[]{0x42100000000080UL,0x4000UL});
		public static readonly BitSet _type_in_type_decl1668 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _VARKEY_in_var_decl1692 = new BitSet(new ulong[]{0x2100000000000UL,0x4000UL});
		public static readonly BitSet _type_id_in_var_decl1694 = new BitSet(new ulong[]{0x10000UL});
		public static readonly BitSet _COLON_in_var_decl1696 = new BitSet(new ulong[]{0x2100000000000UL,0x4000UL});
		public static readonly BitSet _type_id_in_var_decl1698 = new BitSet(new ulong[]{0x1000UL});
		public static readonly BitSet _ASSIGN_in_var_decl1700 = new BitSet(new ulong[]{0x4493501000008000UL,0x4006000UL});
		public static readonly BitSet _expr_in_var_decl1702 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _VARKEY_in_var_decl1723 = new BitSet(new ulong[]{0x2100000000000UL,0x4000UL});
		public static readonly BitSet _type_id_in_var_decl1725 = new BitSet(new ulong[]{0x1000UL});
		public static readonly BitSet _ASSIGN_in_var_decl1727 = new BitSet(new ulong[]{0x4493501000008000UL,0x4006000UL});
		public static readonly BitSet _expr_in_var_decl1729 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FUNCTIONKEY_in_fun_decl1755 = new BitSet(new ulong[]{0x2100000000000UL,0x4000UL});
		public static readonly BitSet _type_id_in_fun_decl1757 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _LPAREN_in_fun_decl1759 = new BitSet(new ulong[]{0x2100000000000UL,0x4800UL});
		public static readonly BitSet _type_fields_in_fun_decl1761 = new BitSet(new ulong[]{0x0UL,0x800UL});
		public static readonly BitSet _RPAREN_in_fun_decl1764 = new BitSet(new ulong[]{0x8010000UL});
		public static readonly BitSet _COLON_in_fun_decl1767 = new BitSet(new ulong[]{0x2100000000000UL,0x4000UL});
		public static readonly BitSet _type_id_in_fun_decl1769 = new BitSet(new ulong[]{0x8000000UL});
		public static readonly BitSet _EQ_in_fun_decl1773 = new BitSet(new ulong[]{0x4493501000008000UL,0x4006000UL});
		public static readonly BitSet _expr_in_fun_decl1775 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _type_id_in_type1834 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _array_decl_in_type1859 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _record_decl_in_type1865 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LKEY_in_record_decl1876 = new BitSet(new ulong[]{0x2100000000000UL,0x4400UL});
		public static readonly BitSet _type_fields_in_record_decl1878 = new BitSet(new ulong[]{0x0UL,0x400UL});
		public static readonly BitSet _RKEY_in_record_decl1881 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ARRAYKEY_in_array_decl1904 = new BitSet(new ulong[]{0x0UL,0x1UL});
		public static readonly BitSet _OFKEY_in_array_decl1906 = new BitSet(new ulong[]{0x2100000000000UL,0x4000UL});
		public static readonly BitSet _type_id_in_array_decl1908 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _type_field_in_type_fields1931 = new BitSet(new ulong[]{0x20002UL});
		public static readonly BitSet _COMMA_in_type_fields1934 = new BitSet(new ulong[]{0x2100000000000UL,0x4000UL});
		public static readonly BitSet _type_field_in_type_fields1936 = new BitSet(new ulong[]{0x20002UL});
		public static readonly BitSet _type_id_in_type_field1957 = new BitSet(new ulong[]{0x10000UL});
		public static readonly BitSet _COLON_in_type_field1959 = new BitSet(new ulong[]{0x2100000000000UL,0x4000UL});
		public static readonly BitSet _type_id_in_type_field1961 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _MINUS_in_atom1986 = new BitSet(new ulong[]{0x4493501000000000UL,0x6000UL});
		public static readonly BitSet _atom_in_atom1988 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _constant_value_in_atom2013 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _lvalue_in_atom2018 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _funcall_in_atom2023 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _if_then_expr_in_atom2028 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _for_expr_in_atom2033 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _let_expr_in_atom2038 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPAREN_in_atom2043 = new BitSet(new ulong[]{0x4493501000008000UL,0x4006800UL});
		public static readonly BitSet _expr_seq_in_atom2045 = new BitSet(new ulong[]{0x0UL,0x800UL});
		public static readonly BitSet _RPAREN_in_atom2047 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IFKEY_in_if_then_expr2086 = new BitSet(new ulong[]{0x4493501000000000UL,0x6000UL});
		public static readonly BitSet _disjunction_expr_in_if_then_expr2090 = new BitSet(new ulong[]{0x0UL,0x8000UL});
		public static readonly BitSet _THENKEY_in_if_then_expr2092 = new BitSet(new ulong[]{0x4493501000008000UL,0x4006000UL});
		public static readonly BitSet _expr_in_if_then_expr2096 = new BitSet(new ulong[]{0x1000002UL});
		public static readonly BitSet _ELSEKEY_in_if_then_expr2099 = new BitSet(new ulong[]{0x4493501000008000UL,0x4006000UL});
		public static readonly BitSet _expr_in_if_then_expr2103 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _WHILEKEY_in_while_stat2136 = new BitSet(new ulong[]{0x4493501000000000UL,0x6000UL});
		public static readonly BitSet _disjunction_expr_in_while_stat2140 = new BitSet(new ulong[]{0x400000UL});
		public static readonly BitSet _DOKEY_in_while_stat2142 = new BitSet(new ulong[]{0x4493501000008000UL,0x4006000UL});
		public static readonly BitSet _expr_in_while_stat2146 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LETKEY_in_let_expr2172 = new BitSet(new ulong[]{0x2000000000UL,0x440000UL});
		public static readonly BitSet _decl_in_let_expr2174 = new BitSet(new ulong[]{0x802000000000UL,0x440000UL});
		public static readonly BitSet _INKEY_in_let_expr2177 = new BitSet(new ulong[]{0x4493501002008000UL,0x4006000UL});
		public static readonly BitSet _expr_seq_in_let_expr2179 = new BitSet(new ulong[]{0x2000000UL});
		public static readonly BitSet _ENDKEY_in_let_expr2181 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _type_id_in_lvalue2211 = new BitSet(new ulong[]{0x4000000800002UL});
		public static readonly BitSet _lvalue_access_in_lvalue2213 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _DOT_in_lvalue_access2236 = new BitSet(new ulong[]{0x2100000000000UL,0x4000UL});
		public static readonly BitSet _type_id_in_lvalue_access2238 = new BitSet(new ulong[]{0x4000000800002UL});
		public static readonly BitSet _lvalue_access_in_lvalue_access2240 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LBRACKET_in_lvalue_access2269 = new BitSet(new ulong[]{0x4493501000000000UL,0x6000UL});
		public static readonly BitSet _disjunction_expr_in_lvalue_access2271 = new BitSet(new ulong[]{0x0UL,0x80UL});
		public static readonly BitSet _RBRACKET_in_lvalue_access2273 = new BitSet(new ulong[]{0x4000000800002UL});
		public static readonly BitSet _lvalue_access_in_lvalue_access2275 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _type_id_in_funcall2301 = new BitSet(new ulong[]{0x80000000000000UL});
		public static readonly BitSet _LPAREN_in_funcall2303 = new BitSet(new ulong[]{0x4493501000008000UL,0x4006800UL});
		public static readonly BitSet _arg_list_in_funcall2305 = new BitSet(new ulong[]{0x0UL,0x800UL});
		public static readonly BitSet _RPAREN_in_funcall2308 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expr_in_expr_seq2334 = new BitSet(new ulong[]{0x2UL,0x1000UL});
		public static readonly BitSet _SEMI_in_expr_seq2337 = new BitSet(new ulong[]{0x4493501000008000UL,0x4006000UL});
		public static readonly BitSet _expr_in_expr_seq2339 = new BitSet(new ulong[]{0x2UL,0x1000UL});
		public static readonly BitSet _expr_in_arg_list2381 = new BitSet(new ulong[]{0x20002UL});
		public static readonly BitSet _COMMA_in_arg_list2384 = new BitSet(new ulong[]{0x4493501000008000UL,0x4006000UL});
		public static readonly BitSet _expr_in_arg_list2386 = new BitSet(new ulong[]{0x20002UL});
		public static readonly BitSet _ID_in_synpred1_tiger1172 = new BitSet(new ulong[]{0x4000000000000UL});
		public static readonly BitSet _LBRACKET_in_synpred1_tiger1174 = new BitSet(new ulong[]{0x4493501000000000UL,0x6000UL});
		public static readonly BitSet _disjunction_expr_in_synpred1_tiger1176 = new BitSet(new ulong[]{0x0UL,0x80UL});
		public static readonly BitSet _RBRACKET_in_synpred1_tiger1178 = new BitSet(new ulong[]{0x0UL,0x1UL});
		public static readonly BitSet _OFKEY_in_synpred1_tiger1180 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _lvalue_in_synpred2_tiger1191 = new BitSet(new ulong[]{0x1000UL});
		public static readonly BitSet _ASSIGN_in_synpred2_tiger1193 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_synpred3_tiger1279 = new BitSet(new ulong[]{0x4000000000000UL});
		public static readonly BitSet _LBRACKET_in_synpred3_tiger1281 = new BitSet(new ulong[]{0x4493501000000000UL,0x6000UL});
		public static readonly BitSet _disjunction_expr_in_synpred3_tiger1283 = new BitSet(new ulong[]{0x0UL,0x80UL});
		public static readonly BitSet _RBRACKET_in_synpred3_tiger1285 = new BitSet(new ulong[]{0x0UL,0x1UL});
		public static readonly BitSet _OFKEY_in_synpred3_tiger1287 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}

} // namespace YATC.Grammar
